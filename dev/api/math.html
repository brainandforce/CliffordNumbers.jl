<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Math · CliffordNumbers.jl</title><meta name="title" content="Math · CliffordNumbers.jl"/><meta property="og:title" content="Math · CliffordNumbers.jl"/><meta property="twitter:title" content="Math · CliffordNumbers.jl"/><meta name="description" content="Documentation for CliffordNumbers.jl."/><meta property="og:description" content="Documentation for CliffordNumbers.jl."/><meta property="twitter:description" content="Documentation for CliffordNumbers.jl."/><meta property="og:url" content="https://brainandforce.github.io/CliffordNumbers.jl/api/math.html"/><meta property="twitter:url" content="https://brainandforce.github.io/CliffordNumbers.jl/api/math.html"/><link rel="canonical" href="https://brainandforce.github.io/CliffordNumbers.jl/api/math.html"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">CliffordNumbers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../numeric.html">Clifford number types</a></li><li><a class="tocitem" href="../metrics.html">Metric signatures</a></li><li><a class="tocitem" href="../indexing.html">Indexing</a></li><li><a class="tocitem" href="../operations.html">Operations</a></li><li><a class="tocitem" href="../performance.html">Performance tips</a></li><li><a class="tocitem" href="../extensions.html">Extensions</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="clifford.html">CliffordNumbers</a></li><li><a class="tocitem" href="indexing.html">Indexing</a></li><li class="is-active"><a class="tocitem" href="math.html">Math</a><ul class="internal"><li><a class="tocitem" href="#Involutions-and-duals"><span>Involutions and duals</span></a></li><li><a class="tocitem" href="#Inverses"><span>Inverses</span></a></li><li><a class="tocitem" href="#Addition-and-subtraction"><span>Addition and subtraction</span></a></li><li><a class="tocitem" href="#Products"><span>Products</span></a></li><li><a class="tocitem" href="#Exponentiation"><span>Exponentiation</span></a></li></ul></li><li><a class="tocitem" href="metrics.html">Metric signatures</a></li><li><a class="tocitem" href="internal.html">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="math.html">Math</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="math.html">Math</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/brainandforce/CliffordNumbers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/main/docs/src/api/math.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mathematical-operations"><a class="docs-heading-anchor" href="#Mathematical-operations">Mathematical operations</a><a id="Mathematical-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-operations" title="Permalink"></a></h1><h2 id="Involutions-and-duals"><a class="docs-heading-anchor" href="#Involutions-and-duals">Involutions and duals</a><a id="Involutions-and-duals-1"></a><a class="docs-heading-anchor-permalink" href="#Involutions-and-duals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reverse-Tuple{BitIndex}-api-math" href="#Base.reverse-Tuple{BitIndex}-api-math"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reverse(i::BitIndex) = i&#39; -&gt; BitIndex
reverse(x::AbstractCliffordNumber) = x&#39; -&gt; typeof(x)</code></pre><p>Performs the reverse operation on the basis blade indexed by <code>b</code> or the Clifford number <code>x</code>. The  sign of the reverse depends on the grade of the basis blade <code>g</code>, and is positive for <code>g % 4 in 0:1</code> and negative for <code>g % 4 in 2:3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/bitindex.jl#L171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint-Tuple{BitIndex}-api-math" href="#Base.adjoint-Tuple{BitIndex}-api-math"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint(i::BitIndex) = i&#39; -&gt; BitIndex
adjoint(x::AbstractCliffordNumber) = x&#39; -&gt; typeof(x)</code></pre><p>An alias for <a href="indexing.html#Base.reverse-Tuple{BitIndex}"><code>reverse(i::BitIndex)</code></a> used to implement operator notation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/bitindex.jl#L181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.grade_involution-Tuple{BitIndex}-api-math" href="#CliffordNumbers.grade_involution-Tuple{BitIndex}-api-math"><code>CliffordNumbers.grade_involution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grade_involution(i::BitIndex) -&gt; BitIndex
grade_involution(x::AbstractCliffordNumber) -&gt; typeof(x)</code></pre><p>Calculates the grade involution of the basis blade indexed by <code>b</code> or the Clifford number <code>x</code>. This effectively reflects all of the basis vectors of the space along their own mirror operation, which makes elements of odd grade flip sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/bitindex.jl#L189-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj-Tuple{BitIndex}-api-math" href="#Base.conj-Tuple{BitIndex}-api-math"><code>Base.conj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj(i::BitIndex) -&gt; BitIndex
conj(x::AbstractCliffordNumber) -&gt; typeof(x)</code></pre><p>Calculates the Clifford conjugate of the basis blade indexed by <code>b</code> or the Clifford number <code>x</code>. This is equal to <code>grade_involution(reverse(x))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/bitindex.jl#L199-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.left_complement-Tuple{BitIndex}-api-math" href="#CliffordNumbers.left_complement-Tuple{BitIndex}-api-math"><code>CliffordNumbers.left_complement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_complement(b::BitIndex{Q}) -&gt; BitIndex{Q}</code></pre><p>Returns the left complement of <code>b</code>, define so that <code>left_complement(b) * b</code> generates the pseudoscalar index of elements of the algebra <code>Q</code>.</p><p>When the left complement is applied twice, the original <code>BitIndex</code> object is returned up to a change of sign, given by <code>(-1)^(grade(b) * (dimension(Q) - grade(b))). This implies that in algebras of odd  dimension, the left complement and [right complement](@ref right_complement) are identical because either</code>grade(b)<code>or</code>dimension(Q) - grade(b)<code>must be even. The complement is independent of the signature of</code>Q`, depending only on the dimension.</p><p>Lengyel&#39;s convention for the left complement is an underbar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/bitindex.jl#L333-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.right_complement-Tuple{BitIndex}-api-math" href="#CliffordNumbers.right_complement-Tuple{BitIndex}-api-math"><code>CliffordNumbers.right_complement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_complement(b::BitIndex{Q}) -&gt; BitIndex{Q}</code></pre><p>Returns the right complement of <code>b</code>, define so that <code>b * right_complement(b)</code> generates the pseudoscalar index of elements of the algebra <code>Q</code>.</p><p>When the right complement is applied twice, the original <code>BitIndex</code> object is returned up to a change of sign, given by <code>(-1)^(grade(b) * (dimension(Q) - grade(b))). This implies that in algebras of odd dimension, the [left complement](@ref left_complement) and right complement are identical because either</code>grade(b)<code>or</code>dimension(Q) - grade(b)<code>must be even. The complement is independent of the signature of</code>Q`, depending only on the dimension.</p><p>Lengyel&#39;s convention for the right complement is an overbar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/bitindex.jl#L349-L362">source</a></section></article><h2 id="Inverses"><a class="docs-heading-anchor" href="#Inverses">Inverses</a><a id="Inverses-1"></a><a class="docs-heading-anchor-permalink" href="#Inverses" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.versor_inverse" href="#CliffordNumbers.versor_inverse"><code>CliffordNumbers.versor_inverse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.versor_inverse(x::AbstractCliffordNumber)</code></pre><p>Calculates the versor inverse of <code>x</code>, equal to <code>x&#39; / abs2(x)</code>.</p><p>The versor inverse is only guaranteed to be an inverse for versors. Not all Clifford numbers have a well-defined inverse, (for instance, in algebras with 2 or more positive-squaring, dimensions, 1 + e₁ has no inverse). To validate the result, use <code>inv(x)</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/inverse.jl#L15-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{AbstractCliffordNumber}" href="#Base.inv-Tuple{AbstractCliffordNumber}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv(x::AbstractCliffordNumber) -&gt; AbstractCliffordNumber</code></pre><p>Calculates the inverse of <code>x</code>, if it exists, using the versor inverse formula <code>x&#39; / abs2(x)</code>. The result is tested to check if its left and right products with <code>x</code> are approximately 1, and a  <code>CliffordNumbers.InverseException</code> is thrown if this test does not pass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/inverse.jl#L26-L32">source</a></section></article><h2 id="Addition-and-subtraction"><a class="docs-heading-anchor" href="#Addition-and-subtraction">Addition and subtraction</a><a id="Addition-and-subtraction-1"></a><a class="docs-heading-anchor-permalink" href="#Addition-and-subtraction" title="Permalink"></a></h2><p>Addition and subtraction integrate seamlessly with those of the Julia Base number types, and no special documentation is included here.</p><h2 id="Products"><a class="docs-heading-anchor" href="#Products">Products</a><a id="Products-1"></a><a class="docs-heading-anchor-permalink" href="#Products" title="Permalink"></a></h2><h3 id="Products-with-scalars"><a class="docs-heading-anchor" href="#Products-with-scalars">Products with scalars</a><a id="Products-with-scalars-1"></a><a class="docs-heading-anchor-permalink" href="#Products-with-scalars" title="Permalink"></a></h3><p>The standard multiplication and division operations (<code>*</code>, <code>/</code>, <code>//</code>) between Clifford numbers and scalars behave as expected. <code>Base.muladd</code> has been overloaded to take advantage of fma instructions available on some hardware platforms.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.muladd-Union{Tuple{T}, Tuple{Union{Real, Complex}, T, T}} where T&lt;:AbstractCliffordNumber" href="#Base.muladd-Union{Tuple{T}, Tuple{Union{Real, Complex}, T, T}} where T&lt;:AbstractCliffordNumber"><code>Base.muladd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">muladd(x::Union{Real,Complex}, y::AbstractCliffordNumber{Q}, z::AbstractCliffordNumber{Q})
muladd(x::AbstractCliffordNumber{Q}, y::Union{Real,Complex}, z::AbstractCliffordNumber{Q})</code></pre><p>Multiplies a scalar with a Clifford number and adds another Clifford number, utilizing optimizations made available with scalar <code>muladd</code>, such as <code>fma</code> if hardware support is available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/scalar.jl#L142-L148">source</a></section></article><h3 id="Geometric-products"><a class="docs-heading-anchor" href="#Geometric-products">Geometric products</a><a id="Geometric-products-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-products" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*" href="#Base.:*"><code>Base.:*</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})
(x::AbstractCliffordNumber{Q})(y::AbstractCliffordNumber{Q})</code></pre><p>Calculates the geometric product of <code>x</code> and <code>y</code>, returning the smallest type which is able to represent all nonzero basis blades of the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/products.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.:⨼" href="#CliffordNumbers.:⨼"><code>CliffordNumbers.:⨼</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_contraction(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})
⨼(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})</code></pre><p>Calculates the left contraction of <code>x</code> and <code>y</code>.</p><p>For basis blades <code>A</code> of grade <code>m</code> and <code>B</code> of grade <code>n</code>, the left contraction is zero if <code>n &lt; m</code>, otherwise it is <code>KVector{n-m,Q}(A*B)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/products.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.:⨽" href="#CliffordNumbers.:⨽"><code>CliffordNumbers.:⨽</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_contraction(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})
⨽(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})</code></pre><p>Calculates the right contraction of <code>x</code> and <code>y</code>.</p><p>For basis blades <code>A</code> of grade <code>m</code> and <code>B</code> of grade <code>n</code>, the right contraction is zero if <code>m &lt; n</code>, otherwise it is <code>KVector{m-n,Q}(A*B)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/products.jl#L69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.dot" href="#CliffordNumbers.dot"><code>CliffordNumbers.dot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.dot(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})</code></pre><p>Calculates the dot product of <code>x</code> and <code>y</code>.</p><p>For basis blades <code>A</code> of grade <code>m</code> and <code>B</code> of grade <code>n</code>, the dot product is equal to the left contraction when <code>m &gt;= n</code> and is equal to the right contraction (up to sign) when <code>n &gt;= m</code>.</p><p><strong>Why is this function not exported?</strong></p><p>The LinearAlgebra package also defines a <code>dot</code> function, and if both packages are used together, this will cause a name conflict if <code>CliffordNumbers.dot</code> is exported. In the future, we will try to resolve this without requiring a LinearAlgebra dependency.</p><p>Additionally, there is reason to prefer the use of the left and right contractions over the dot product because the contractions require fewer exceptions in their definitions and properties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/products.jl#L80-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.hestenes_dot" href="#CliffordNumbers.hestenes_dot"><code>CliffordNumbers.hestenes_dot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.hestenes_dot(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})</code></pre><p>Returns the Hestenes product: this is equal to the dot product given by <code>dot(x, y)</code> but is equal to to zero when either <code>x</code> or <code>y</code> is a scalar.</p><p><strong>Why is this function not exported?</strong></p><p>In almost every case, left and right contractions are preferable - the dot product and the Hestenes product are less regular in algebraic sense, and the conditionals present in its implementation  slow it down relative to contractions. It is provided for the sake of exact reproducibility of results which use it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/products.jl#L99-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.:∧" href="#CliffordNumbers.:∧"><code>CliffordNumbers.:∧</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∧(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})
wedge(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})</code></pre><p>Calculates the wedge (outer) product of two Clifford numbers <code>x</code> and <code>y</code> with quadratic form <code>Q</code>.</p><p>Note that the wedge product, in general, is <em>not</em> equal to the commutator product (or antisymmetric product), which may be invoked with the <code>commutator</code> function or the <code>×</code> operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/products.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.:∨" href="#CliffordNumbers.:∨"><code>CliffordNumbers.:∨</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∨(x::AbstractCliffordNumber, y::AbstractCliffordNumber)
regressive(x::AbstractCliffordNumber, y::AbstractCliffordNumber)</code></pre><p>Calculates the regressive product of <code>x</code> and <code>y</code>. This is accomplished by taking the wedge product of the left complements of <code>x</code> and <code>y</code>, then taking the right complement of the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/products.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.:×" href="#CliffordNumbers.:×"><code>CliffordNumbers.:×</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">×(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})
commutator(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})</code></pre><p>Calculates the commutator (or antisymmetric) product, equal to <code>1//2 * (x*y - y*x)</code>.</p><p>Note that the commutator product, in general, is <em>not</em> equal to the wedge product, which may be invoked with the <code>wedge</code> function or the <code>∧</code> operator.</p><p><strong>Type promotion</strong></p><p>Because of the rational <code>1//2</code> factor in the product, inputs with scalar types subtyping <code>Integer</code> will be promoted to <code>Rational</code> subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/products.jl#L123-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.:⨰" href="#CliffordNumbers.:⨰"><code>CliffordNumbers.:⨰</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⨰(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})
anticommutator(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})</code></pre><p>Calculates the anticommutator (or symmetric) product, equal to <code>1//2 * (x*y + y*x)</code>.</p><p>Note that the dot product, in general, is <em>not</em> equal to the anticommutator product, which may be invoked with <code>dot</code>. In some cases, the preferred operators might be the left and right contractions, which use infix operators <code>⨼</code> and <code>⨽</code> respectively.</p><p><strong>Type promotion</strong></p><p>Because of the rational <code>1//2</code> factor in the product, inputs with scalar types subtyping <code>Integer</code> will be promoted to <code>Rational</code> subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/products.jl#L141-L155">source</a></section></article><h3 id="Scalar-products-and-normalization"><a class="docs-heading-anchor" href="#Scalar-products-and-normalization">Scalar products and normalization</a><a id="Scalar-products-and-normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-products-and-normalization" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.scalar_product" href="#CliffordNumbers.scalar_product"><code>CliffordNumbers.scalar_product</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scalar_product(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})</code></pre><p>Calculates the scalar product of two Clifford numbers with quadratic form <code>Q</code>. The result is a <code>Real</code> or <code>Complex</code> number. This can be converted back to an <code>AbstractCliffordNumber</code>.</p><p>The result is equal to <code>scalar(x * y)</code>, but does not calculate the coefficients associated with any other basis blades.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/scalar.jl#L48-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.abs2-Tuple{AbstractCliffordNumber}" href="#Base.abs2-Tuple{AbstractCliffordNumber}"><code>Base.abs2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abs2(x::AbstractCliffordNumber{Q,T}) -&gt; T</code></pre><p>Calculates the modulus of <code>x</code> by calculating the scalar product of <code>x</code> with its reverse: <code>scalar_product(x, x&#39;)</code>. In positive-definite metrics, this value is positive for any nonzero  multivector and equal to <code>zero(T)</code> for any multivector equal to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/scalar.jl#L72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.abs-Tuple{AbstractCliffordNumber}" href="#Base.abs-Tuple{AbstractCliffordNumber}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abs(x::AbstractCliffordNumber{Q}) -&gt; Union{Real,Complex}</code></pre><p>Calculates the norm of <code>x</code>, equal to <code>sqrt(abs(abs2(x)))</code>.</p><p>The inclusion of <code>abs</code> in this expression accounts for the possibility that the algebra <code>Q</code> contains 1-blades with a negative square, which would result in <code>abs(x)</code> being imaginary. In these cases, <code>abs(x)</code> may not be a norm, but it is used internally by <code>normalize(x)</code> to calculate a normalization factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/scalar.jl#L81-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.normalize" href="#CliffordNumbers.normalize"><code>CliffordNumbers.normalize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize(x::AbstractCliffordNumber{Q}) -&gt; AbstractCliffordNumber{Q}</code></pre><p>Normalizes <code>x</code> so that its modulus (as calculated by <code>abs2</code>) is 1, 0, or -1. This procedure cannot change the sign of the modulus.</p><p>If <code>abs2(x)</code> is zero (possible in any non-positive-definite metric), <code>x</code> is returned unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/scalar.jl#L93-L100">source</a></section></article><h2 id="Exponentiation"><a class="docs-heading-anchor" href="#Exponentiation">Exponentiation</a><a id="Exponentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Exponentiation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Tuple{AbstractCliffordNumber}" href="#Base.exp-Tuple{AbstractCliffordNumber}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(x::AbstractCliffordNumber{Q})</code></pre><p>Returns the natural exponential of a Clifford number.</p><p>For special cases where m squares to a scalar, the following shortcuts can be used to calculate <code>exp(x)</code>:</p><ul><li>When x^2 &lt; 0: <code>exp(x) === cos(abs(x)) + x * sin(abs(x)) / abs(x)</code></li><li>When x^2 &gt; 0: <code>exp(x) === cosh(abs(x)) + x * sinh(abs(x)) / abs(x)</code></li><li>When x^2 == 0: <code>exp(x) == 1 + x</code></li></ul><p>See also: <a href="math.html#CliffordNumbers.exppi"><code>exppi</code></a>, <a href="math.html#CliffordNumbers.exptau"><code>exptau</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/exponential.jl#L132-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.exppi" href="#CliffordNumbers.exppi"><code>CliffordNumbers.exppi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exppi(x::AbstractCliffordNumber)</code></pre><p>Returns the natural exponential of <code>π * x</code> with greater accuracy than <code>exp(π * x)</code> in the case where <code>x^2</code> is a negative scalar, especially for large values of <code>abs(x)</code>.</p><p>See also: <a href="math.html#Base.exp-Tuple{AbstractCliffordNumber}"><code>exp</code></a>, <a href="math.html#CliffordNumbers.exptau"><code>exptau</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/exponential.jl#L158-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.exptau" href="#CliffordNumbers.exptau"><code>CliffordNumbers.exptau</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exptau(x::AbstractCliffordNumber)</code></pre><p>Returns the natural exponential of <code>2π * x</code> with greater accuracy than <code>exp(2π * x)</code> in the case where <code>x^2</code> is a negative scalar, especially for large values of <code>abs(x)</code>.</p><p>See also: <a href="math.html#Base.exp-Tuple{AbstractCliffordNumber}"><code>exp</code></a>, <a href="math.html#CliffordNumbers.exppi"><code>exppi</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/f1f49a4cc3e147379fcf4ef8c1f1143b2052debf/src/math/exponential.jl#L181-L188">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="indexing.html">« Indexing</a><a class="docs-footer-nextpage" href="metrics.html">Metric signatures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 5 November 2024 01:16">Tuesday 5 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
