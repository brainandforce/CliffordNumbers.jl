<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CliffordNumbers · CliffordNumbers.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://brainandforce.github.io/CliffordNumbers.jl/api/clifford.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">CliffordNumbers.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../numeric.html">Clifford number types</a></li><li><a class="tocitem" href="../metrics.html">Metric signatures</a></li><li><a class="tocitem" href="../operations.html">Operations</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href="clifford.html">CliffordNumbers</a><ul class="internal"><li><a class="tocitem" href="#Supertype-and-associated-functions"><span>Supertype and associated functions</span></a></li><li><a class="tocitem" href="#Concrete-types"><span>Concrete types</span></a></li><li><a class="tocitem" href="#Promotion-and-conversion"><span>Promotion and conversion</span></a></li><li><a class="tocitem" href="#Real-and-complex-algebras"><span>Real and complex algebras</span></a></li><li><a class="tocitem" href="#Scalar-and-pseudoscalar-components"><span>Scalar and pseudoscalar components</span></a></li></ul></li><li><a class="tocitem" href="indexing.html">Indexing</a></li><li><a class="tocitem" href="math.html">Math</a></li><li><a class="tocitem" href="metrics.html">Metric signatures</a></li><li><a class="tocitem" href="internal.html">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="clifford.html">CliffordNumbers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="clifford.html">CliffordNumbers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/main/docs/src/api/clifford.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Clifford-numbers"><a class="docs-heading-anchor" href="#Clifford-numbers">Clifford numbers</a><a id="Clifford-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Clifford-numbers" title="Permalink"></a></h1><h2 id="Supertype-and-associated-functions"><a class="docs-heading-anchor" href="#Supertype-and-associated-functions">Supertype and associated functions</a><a id="Supertype-and-associated-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Supertype-and-associated-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.AbstractCliffordNumber" href="#CliffordNumbers.AbstractCliffordNumber"><code>CliffordNumbers.AbstractCliffordNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCliffordNumber{Q,T} &lt;: Number</code></pre><p>An element of a Clifford algebra, often referred to as a multivector, with quadratic form <code>Q</code> and element type <code>T</code>.</p><p><strong>Interface</strong></p><p><strong>Required implementation</strong></p><p>All subtypes <code>C</code> of <code>AbstractCliffordNumber{Q}</code> must implement the following functions:</p><ul><li><code>Base.length(x::C)</code> should return the number of nonzero basis elements represented by <code>x</code>.</li><li><code>CliffordNumbers.similar_type(::Type{C}, ::Type{T}, ::Type{Q}) where {C,T,Q}</code> should construct a</li></ul><p>new type similar to <code>C</code> which subtypes <code>AbstractCliffordNumber{Q,T}</code> that may serve as a constructor.</p><ul><li><code>Base.getindex(x::C, b::BitIndex{Q})</code> should allow one to recover the coefficients associated</li></ul><p>with each basis blade represented by <code>C</code>.</p><p><strong>Required implementation for static types</strong></p><ul><li><code>Base.length(::Type{C})</code> should be defined, with <code>Base.length(x::C) = length(typeof(x))</code>.</li><li><code>Base.Tuple(x::C)</code> should return the tuple used to construct <code>x</code>. The fallback is</li></ul><p><code>getfield(x, :data)::Tuple</code>, so any type declared with a <code>NTuple</code> field named <code>data</code> should have this defined automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/abstract.jl#L2-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.scalar_type" href="#CliffordNumbers.scalar_type"><code>CliffordNumbers.scalar_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scalar_type(::Type{&lt;:AbstractCliffordNumber{Q,T}}) = T
scalar_type(T::Type{&lt;:Union{Real,Complex}}) = T
scalar_type(x) = scalar_type(typeof(x))</code></pre><p>Returns the numeric type associated with an <code>AbstractCliffordNumber</code> instance. For subtypes of <code>Real</code> and <code>Complex</code>, or their instances, this simply returns the input type or instance type.</p><p><strong>Why not define <code>eltype</code>?</strong></p><p><code>AbstractCliffordNumber</code> instances behave like numbers, not arrays. If <code>collect()</code> is called on a Clifford number of type <code>T</code>, it should not construct a vector of coefficients; instead it should return an <code>Array{T,0}</code>. Similarly, a broadcasted multiplication should return the same result as normal multiplication, as is the case with complex numbers.</p><p>For subtypes <code>T</code> of <code>Number</code>, <code>eltype(T) === T</code>, and this is true for <code>AbstractCliffordNumber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/abstract.jl#L43-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.similar_type" href="#CliffordNumbers.similar_type"><code>CliffordNumbers.similar_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.similar_type(
    C::Type{&lt;:AbstractCliffordNumber},
    [N::Type{&lt;:BaseNumber} = scalar_type(C)],
    [Q::Val = Val(signature(C))]
) -&gt; Type{&lt;:AbstractCliffordNumber{Q,N}}</code></pre><p>Constructs a type similar to <code>T</code> but with numeric type <code>N</code> and quadratic form <code>Q</code>. The quadratic form must be wrapped in a <code>Val</code> to preserve type stability.</p><p>This function must be defined with all its arguments for each concrete type subtyping <code>AbstractCliffordNumber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/abstract.jl#L94-L106">source</a></section></article><h2 id="Concrete-types"><a class="docs-heading-anchor" href="#Concrete-types">Concrete types</a><a id="Concrete-types-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.CliffordNumber" href="#CliffordNumbers.CliffordNumber"><code>CliffordNumbers.CliffordNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumber{Q,T,L} &lt;: AbstractCliffordNumber{Q,T}</code></pre><p>A dense multivector (or Clifford number), with quadratic form <code>Q</code>, element type <code>T</code>, and length <code>L</code> (which depends entirely on <code>Q</code>).</p><p>The coefficients are ordered by taking advantage of the natural binary structure of the basis. The grade of an element is given by the Hamming weight of its index. For the algebra of physical space, the order is: 1, e₁, e₂, e₁₂, e₃, e₁₃, e₂₃, e₁₂₃ = i. This order allows for more aggressive SIMD optimization when calculating the geometric product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/cliffordnumber.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.Z2CliffordNumber" href="#CliffordNumbers.Z2CliffordNumber"><code>CliffordNumbers.Z2CliffordNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.Z2CliffordNumber{P,Q,T,L} &lt;: AbstractCliffordNumber{Q,T}</code></pre><p>A Clifford number whose only nonzero grades are even or odd. Clifford numbers of this form naturally arise as versors, the geometric product of 1-vectors.</p><p>The type parameter <code>P</code> is constrained to be a <code>Bool</code>: <code>true</code> for odd grade Clifford numbers, and <code>false</code> for even grade Clifford numbers, corresponding to the Boolean result of each grade modulo 2.</p><p><strong>Type aliases</strong></p><p>This type is not exported, and usually you will want to refer to the following aliases:</p><pre><code class="nohighlight hljs">const EvenCliffordNumber{Q,T,L} = Z2CliffordNumber{false,Q,T,L}
const OddCliffordNumber{Q,T,L} = Z2CliffordNumber{true,Q,T,L}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/even.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.EvenCliffordNumber" href="#CliffordNumbers.EvenCliffordNumber"><code>CliffordNumbers.EvenCliffordNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EvenCliffordNumber{P,Q,T,L} (alias for CliffordNumbers.Z2CliffordNumber{false,Q,T,L})</code></pre><p>A Clifford number whose only nonzero grades are even. These are the natural choice of representation for rotors and motors (Euclidean isometries preserving orientation, or &quot;proper&quot; isometries), as well as their composition with dilations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/even.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.OddCliffordNumber" href="#CliffordNumbers.OddCliffordNumber"><code>CliffordNumbers.OddCliffordNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OddCliffordNumber{P,Q,T,L} (alias for CliffordNumbers.Z2CliffordNumber{true,Q,T,L})</code></pre><p>A Clifford number whose only nonzero grades are odd. These are the natural choice of representation for reflections, as well as their compositions with rotors and motors (Euclidean isometries  preserving orientation, or &quot;proper&quot; isometries), as well as their composition with dilations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/even.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.KVector" href="#CliffordNumbers.KVector"><code>CliffordNumbers.KVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KVector{K,Q,T,L} &lt;: AbstractCliffordNumber{Q,T}</code></pre><p>A multivector consisting only linear combinations of basis blades of grade <code>K</code> - in other words, a k-vector.</p><p>k-vectors have <code>binomial(dimension(Q), K)</code> components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/kvector.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.grade-Union{Tuple{Type{&lt;:KVector{K}}}, Tuple{K}} where K" href="#CliffordNumbers.grade-Union{Tuple{Type{&lt;:KVector{K}}}, Tuple{K}} where K"><code>CliffordNumbers.grade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grade(::Type{&lt;:KVector{K}}) = K
grade(x::KVector{K}) = k</code></pre><p>Returns the grade represented by a <code>KVector{K}</code>, which is K.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/kvector.jl#L36-L41">source</a></section></article><h2 id="Promotion-and-conversion"><a class="docs-heading-anchor" href="#Promotion-and-conversion">Promotion and conversion</a><a id="Promotion-and-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Promotion-and-conversion" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.scalar_convert" href="#CliffordNumbers.scalar_convert"><code>CliffordNumbers.scalar_convert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scalar_convert(T::Type{&lt;:Union{Real,Complex}}, x::AbstractCliffordNumber) -&gt; T
scalar_convert(T::Type{&lt;:Union{Real,Complex}}, x::Union{Real,Complex}) -&gt; T</code></pre><p>If <code>x</code> is an <code>AbstractCliffordNumber</code>, converts the scalars of <code>x</code> to type <code>T</code>.</p><p>If <code>x</code> is a <code>Real</code> or <code>Complex</code>, converts <code>x</code> to <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; scalar_convert(Float32, KVector{1,APS}(1, 2, 3))
3-element KVector{1, VGA(3), Float32}:
1.0σ₁ + 2.0σ₂ + 3.0σ

julia&gt; scalar_convert(Float32, 2)
2.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/convert.jl#L27-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.scalar_promote" href="#CliffordNumbers.scalar_promote"><code>CliffordNumbers.scalar_promote</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scalar_promote(x::AbstractCliffordNumber, y::AbstractCliffordNumber)</code></pre><p>Promotes the scalar types of <code>x</code> and <code>y</code> to a common type. This does not increase the number of represented grades of either <code>x</code> or <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/promote.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.widen-Union{Tuple{Type{&lt;:AbstractCliffordNumber{Q, T}}}, Tuple{T}, Tuple{Q}} where {Q, T}" href="#Base.widen-Union{Tuple{Type{&lt;:AbstractCliffordNumber{Q, T}}}, Tuple{T}, Tuple{Q}} where {Q, T}"><code>Base.widen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">widen(C::Type{&lt;:AbstractCliffordNumber})
widen(x::AbstractCliffordNumber)</code></pre><p>Construct a new type whose scalar type is widened. This behavior matches that of <code>widen(C::Type{Complex{T}})</code>, which results in widening of its scalar type <code>T</code>.</p><p>For obtaining a representation of a Clifford number with an increased number of nonzero grades, use <code>widen_grade(T)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/promote.jl#L130-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.widen_grade" href="#CliffordNumbers.widen_grade"><code>CliffordNumbers.widen_grade</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">widen_grade(C::Type{&lt;:AbstractCliffordNumber})
widen_grade(x::AbstractCliffordNumber)</code></pre><p>For type arguments, construct the next largest type that can hold all of the grades of <code>C</code>. <code>KVector{K,Q,T}</code> widens to <code>EvenCliffordNumber{Q,T}</code> or <code>OddCliffordNumber{Q,T}</code>, and <code>EvenCliffordNumber{Q,T}</code> and <code>OddCliffordNumber{Q,T}</code> widen to <code>CliffordNumber{Q,T}</code>, which is the widest type.</p><p>For <code>AbstractCliffordNumber</code> arguments, the argument is converted to the result of <code>widen_grade(typeof(x))</code>.</p><p>For widening the scalar type of an <code>AbstractCliffordNumber</code>, use <code>Base.widen(T)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/promote.jl#L142-L155">source</a></section></article><h2 id="Real-and-complex-algebras"><a class="docs-heading-anchor" href="#Real-and-complex-algebras">Real and complex algebras</a><a id="Real-and-complex-algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Real-and-complex-algebras" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.real-Tuple{AbstractCliffordNumber}" href="#Base.real-Tuple{AbstractCliffordNumber}"><code>Base.real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real(x::AbstractCliffordNumber{Q,T})</code></pre><p>Gets the real portion of each coefficient of <code>x</code>. For <code>T&lt;:Real</code> this operation does nothing; for <code>T&lt;:Complex{S}</code> this an <code>AbstractCliffordNumber{Q,S}</code>.</p><p>Note that this does not return the scalar (grade 0) coefficient of <code>x</code>. Use <code>real(scalar(x))</code> to obtain this result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/abstract.jl#L118-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.complex-Tuple{AbstractCliffordNumber}" href="#Base.complex-Tuple{AbstractCliffordNumber}"><code>Base.complex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complex(x::AbstractCliffordNumber, [y::AbstractCliffordNumber = zero(typeof(x))])</code></pre><p>For a single argument <code>x</code>, converts the type of each coefficient to a suitable complex type.</p><p>For two arguments <code>x</code> and <code>y</code>, which are both real Clifford numbers, performs the sum <code>x + y*im</code>, constructing a complex Clifford number.</p><p>Note that this operation does not isolate a scalar (grade 0) coefficient of <code>x</code> or <code>y</code>. Use <code>complex(scalar(x), [scalar(y)])</code> to obtain this result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/abstract.jl#L134-L144">source</a></section></article><h2 id="Scalar-and-pseudoscalar-components"><a class="docs-heading-anchor" href="#Scalar-and-pseudoscalar-components">Scalar and pseudoscalar components</a><a id="Scalar-and-pseudoscalar-components-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-and-pseudoscalar-components" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.isscalar" href="#CliffordNumbers.isscalar"><code>CliffordNumbers.isscalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isscalar(x::AbstractCliffordNumber)</code></pre><p>Determines whether the Clifford number <code>x</code> is a scalar, meaning that all of its blades of nonzero grade are zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/math.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.ispseudoscalar" href="#CliffordNumbers.ispseudoscalar"><code>CliffordNumbers.ispseudoscalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ispseudoscalar(m::AbstractCliffordNumber)</code></pre><p>Determines whether the Clifford number <code>x</code> is a pseudoscalar, meaning that all of its blades with grades below the dimension of the space are zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/math.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.scalar" href="#CliffordNumbers.scalar"><code>CliffordNumbers.scalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scalar(x::AbstractCliffordNumber{Q,T}) -&gt; T</code></pre><p>Returns the scalar portion of <code>x</code> as its scalar type. This is equivalent to <code>x[scalar_index(x)]</code>.</p><p>To retain Clifford number semantics, use the <code>KVector{0}</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cee1fc87f2ca4a40851c28d2be9ac172d9d5b474/src/math.jl#L19-L25">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operations.html">« Operations</a><a class="docs-footer-nextpage" href="indexing.html">Indexing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 14 May 2024 02:52">Tuesday 14 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
