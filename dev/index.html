<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CliffordNumbers.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://brainandforce.github.io/CliffordNumbers.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CliffordNumbers.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CliffordNumbers"><a class="docs-heading-anchor" href="#CliffordNumbers">CliffordNumbers</a><a id="CliffordNumbers-1"></a><a class="docs-heading-anchor-permalink" href="#CliffordNumbers" title="Permalink"></a></h1><p><a href="https://github.com/brainandforce/CliffordNumbers.jl">CliffordNumbers.jl</a> is a package that provides fully static multivectors (Clifford numbers) in arbitrary dimensions and metrics. While in many cases, sparse representations of multivectors are more efficient, for spaces of low dimension, dense static representations may provide a performance and convenience advantage.</p><ul><li><a href="#CliffordNumbers.APS"><code>CliffordNumbers.APS</code></a></li><li><a href="#CliffordNumbers.AbstractBitIndices"><code>CliffordNumbers.AbstractBitIndices</code></a></li><li><a href="#CliffordNumbers.AbstractCliffordNumber"><code>CliffordNumbers.AbstractCliffordNumber</code></a></li><li><a href="#CliffordNumbers.BaseNumber"><code>CliffordNumbers.BaseNumber</code></a></li><li><a href="#CliffordNumbers.BitIndex-Union{Tuple{Vararg{Integer}}, Tuple{Q}} where Q"><code>CliffordNumbers.BitIndex</code></a></li><li><a href="#CliffordNumbers.BitIndex"><code>CliffordNumbers.BitIndex</code></a></li><li><a href="#CliffordNumbers.BitIndices"><code>CliffordNumbers.BitIndices</code></a></li><li><a href="#CliffordNumbers.CliffordNumber"><code>CliffordNumbers.CliffordNumber</code></a></li><li><a href="#CliffordNumbers.KVector"><code>CliffordNumbers.KVector</code></a></li><li><a href="#CliffordNumbers.QFComplex"><code>CliffordNumbers.QFComplex</code></a></li><li><a href="#CliffordNumbers.QFReal"><code>CliffordNumbers.QFReal</code></a></li><li><a href="#CliffordNumbers.QuadraticForm"><code>CliffordNumbers.QuadraticForm</code></a></li><li><a href="#CliffordNumbers.RepresentedGrades"><code>CliffordNumbers.RepresentedGrades</code></a></li><li><a href="#CliffordNumbers.STA"><code>CliffordNumbers.STA</code></a></li><li><a href="#CliffordNumbers.TransformedBitIndices"><code>CliffordNumbers.TransformedBitIndices</code></a></li><li><a href="#CliffordNumbers.Z2CliffordNumber"><code>CliffordNumbers.Z2CliffordNumber</code></a></li><li><a href="#Base.:*-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q"><code>Base.:*</code></a></li><li><a href="#Base.abs-Tuple{AbstractCliffordNumber}"><code>Base.abs</code></a></li><li><a href="#Base.abs2-Tuple{AbstractCliffordNumber}"><code>Base.abs2</code></a></li><li><a href="#Base.conj-Tuple{BitIndex}"><code>Base.conj</code></a></li><li><a href="#Base.exp-Tuple{CliffordNumber}"><code>Base.exp</code></a></li><li><a href="#Base.real-Union{Tuple{AbstractCliffordNumber{Q, &lt;:Real}}, Tuple{Q}} where Q"><code>Base.real</code></a></li><li><a href="#Base.reverse-Tuple{BitIndex}"><code>Base.reverse</code></a></li><li><a href="#Base.sign-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{Type{QuadraticForm{P, Q, R}}, Integer}} where {P, Q, R}"><code>Base.sign</code></a></li><li><a href="#CliffordNumbers.CGA-Tuple{Any}"><code>CliffordNumbers.CGA</code></a></li><li><a href="#CliffordNumbers.PGA-Tuple{Any}"><code>CliffordNumbers.PGA</code></a></li><li><a href="#CliffordNumbers.VGA-Tuple{Any}"><code>CliffordNumbers.VGA</code></a></li><li><a href="#CliffordNumbers._sort_with_parity!-Tuple{AbstractVector{&lt;:Real}}"><code>CliffordNumbers._sort_with_parity!</code></a></li><li><a href="#CliffordNumbers.check_element_count-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Any, Type{QuadraticForm{X, Y, Z}}, Any}} where {X, Y, Z}"><code>CliffordNumbers.check_element_count</code></a></li><li><a href="#CliffordNumbers.commutator-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q"><code>CliffordNumbers.commutator</code></a></li><li><a href="#CliffordNumbers.dot-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.dot</code></a></li><li><a href="#CliffordNumbers.dual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q"><code>CliffordNumbers.dual</code></a></li><li><a href="#CliffordNumbers.elementwise_product-Union{Tuple{C}, Tuple{Q}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}, Bool}} where {Q, C&lt;:(AbstractCliffordNumber{Q})}"><code>CliffordNumbers.elementwise_product</code></a></li><li><a href="#CliffordNumbers.evil_number-Tuple{Integer}"><code>CliffordNumbers.evil_number</code></a></li><li><a href="#CliffordNumbers.exppi-Tuple{CliffordNumber}"><code>CliffordNumbers.exppi</code></a></li><li><a href="#CliffordNumbers.exptau-Tuple{CliffordNumber}"><code>CliffordNumbers.exptau</code></a></li><li><a href="#CliffordNumbers.grade_involution-Tuple{BitIndex}"><code>CliffordNumbers.grade_involution</code></a></li><li><a href="#CliffordNumbers.hamming_number-Tuple{Integer, Integer}"><code>CliffordNumbers.hamming_number</code></a></li><li><a href="#CliffordNumbers.has_grades_of-Tuple{Type{&lt;:AbstractCliffordNumber}, Type{&lt;:AbstractCliffordNumber}}"><code>CliffordNumbers.has_grades_of</code></a></li><li><a href="#CliffordNumbers.has_wedge-Union{Tuple{Q}, Tuple{BitIndex{Q}, BitIndex{Q}}} where Q"><code>CliffordNumbers.has_wedge</code></a></li><li><a href="#CliffordNumbers.hestenes_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.hestenes_product</code></a></li><li><a href="#CliffordNumbers.isevil-Tuple{Integer}"><code>CliffordNumbers.isevil</code></a></li><li><a href="#CliffordNumbers.isodious-Tuple{Integer}"><code>CliffordNumbers.isodious</code></a></li><li><a href="#CliffordNumbers.ispseudoscalar-Tuple{CliffordNumber}"><code>CliffordNumbers.ispseudoscalar</code></a></li><li><a href="#CliffordNumbers.isscalar-Tuple{CliffordNumber}"><code>CliffordNumbers.isscalar</code></a></li><li><a href="#CliffordNumbers.next_of_hamming_weight-Tuple{Integer}"><code>CliffordNumbers.next_of_hamming_weight</code></a></li><li><a href="#CliffordNumbers.nonzero_grades-Tuple{Number}"><code>CliffordNumbers.nonzero_grades</code></a></li><li><a href="#CliffordNumbers.normalize-Tuple{AbstractCliffordNumber}"><code>CliffordNumbers.normalize</code></a></li><li><a href="#CliffordNumbers.number_of_parity-Tuple{Integer, Bool}"><code>CliffordNumbers.number_of_parity</code></a></li><li><a href="#CliffordNumbers.numeric_type-Tuple{Type}"><code>CliffordNumbers.numeric_type</code></a></li><li><a href="#CliffordNumbers.odious_number-Tuple{Integer}"><code>CliffordNumbers.odious_number</code></a></li><li><a href="#CliffordNumbers.promote_numeric_type-Tuple{}"><code>CliffordNumbers.promote_numeric_type</code></a></li><li><a href="#CliffordNumbers.sandwich-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.sandwich</code></a></li><li><a href="#CliffordNumbers.scalar_product-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q"><code>CliffordNumbers.scalar_product</code></a></li><li><a href="#CliffordNumbers.select_grade-Tuple{CliffordNumber, Integer}"><code>CliffordNumbers.select_grade</code></a></li><li><a href="#CliffordNumbers.sign_of_mult-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{BitIndex{QuadraticForm{P, Q, R}}, BitIndex{QuadraticForm{P, Q, R}}}} where {P, Q, R}"><code>CliffordNumbers.sign_of_mult</code></a></li><li><a href="#CliffordNumbers.signbit_of_mult-Tuple{Unsigned, Unsigned}"><code>CliffordNumbers.signbit_of_mult</code></a></li><li><a href="#CliffordNumbers.signmask"><code>CliffordNumbers.signmask</code></a></li><li><a href="#CliffordNumbers.similar_type-Tuple{AbstractCliffordNumber, Type{&lt;:Union{Real, Complex}}, Type{&lt;:QuadraticForm}}"><code>CliffordNumbers.similar_type</code></a></li><li><a href="#CliffordNumbers.subscript_string-Tuple{Number}"><code>CliffordNumbers.subscript_string</code></a></li><li><a href="#CliffordNumbers.to_basis_str-Union{Tuple{BitIndex{Q}}, Tuple{Q}} where Q"><code>CliffordNumbers.to_basis_str</code></a></li><li><a href="#CliffordNumbers.undual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q"><code>CliffordNumbers.undual</code></a></li><li><a href="#CliffordNumbers.versor_inverse-Tuple{CliffordNumber}"><code>CliffordNumbers.versor_inverse</code></a></li><li><a href="#CliffordNumbers.wedge-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q"><code>CliffordNumbers.wedge</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.BaseNumber" href="#CliffordNumbers.BaseNumber"><code>CliffordNumbers.BaseNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.BaseNumber</code></pre><p>Union of subtypes of <code>Number</code> provided in the Julia <code>Base</code> module: <code>Real</code> and <code>Complex</code>. This encompasses all types that may be used to construct a <code>CliffordNumber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/CliffordNumbers.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.APS" href="#CliffordNumbers.APS"><code>CliffordNumbers.APS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">APS</code></pre><p>The algebra of physical space, Cl(3,0,0). An alias for <code>QuadraticForm{3,0,0}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/quadratic.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.AbstractBitIndices" href="#CliffordNumbers.AbstractBitIndices"><code>CliffordNumbers.AbstractBitIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBitIndices{Q,C&lt;:AbstractCliffordNumber{Q}} &lt;: AbstractVector{BitIndex{Q}}</code></pre><p>Supertype for vectors containing all valid <code>BitIndex{Q}</code> objects for the basis elements represented by <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindices.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.AbstractCliffordNumber" href="#CliffordNumbers.AbstractCliffordNumber"><code>CliffordNumbers.AbstractCliffordNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCliffordNumber{Q,T} &lt;: Number</code></pre><p>An element of a Clifford algebra, often referred to as a multivector, with quadratic form <code>Q</code> and element type <code>T</code>.</p><p><strong>Interface</strong></p><p><strong>Required implementation</strong></p><p>All subtypes <code>C</code> of <code>AbstractCliffordNumber{Q}</code> must implement the following functions:</p><ul><li><code>Base.length(x::C)</code> should return the number of nonzero basis elements represented by <code>x</code>.</li><li><code>CliffordNumbers.similar_type(::Type{C}, ::Type{T}, ::Type{Q}) where {C,T,Q}</code> should construct a</li></ul><p>new type similar to <code>C</code> which subtypes <code>AbstractCliffordNumber{Q,T}</code> that may serve as a constructor.</p><ul><li><code>Base.getindex(x::C, b::BitIndex{Q})</code> should allow one to recover the coefficients associated</li></ul><p>with each basis blade represented by <code>C</code>.</p><p><strong>Required implementation for static types</strong></p><ul><li><code>Base.length(::Type{C})</code> should be defined, with <code>Base.length(x::C) = length(typeof(x))</code>.</li><li><code>Base.Tuple(x::C)</code> should return the tuple used to construct <code>x</code>. The fallback is</li></ul><p><code>getfield(x, :data)::Tuple</code>, so any type declared with a <code>NTuple</code> field named <code>data</code> should have this defined automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/abstract.jl#L2-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.BitIndex" href="#CliffordNumbers.BitIndex"><code>CliffordNumbers.BitIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BitIndex{Q&lt;:QuadraticForm}</code></pre><p>A representation of an index corresponding to a basis blade of the geometric algebra with quadratic form <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindex.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.BitIndex-Union{Tuple{Vararg{Integer}}, Tuple{Q}} where Q" href="#CliffordNumbers.BitIndex-Union{Tuple{Vararg{Integer}}, Tuple{Q}} where Q"><code>CliffordNumbers.BitIndex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BitIndex{Q}(x::Integer...)
BitIndex{Q}(v::AbstractVector{&lt;:Integer})</code></pre><p>Constructs a <code>BitIndex{Q}</code> from a list of integers that represent the basis vectors of the space.</p><p>This package uses a lexicographic convention for basis blades: in the algebra of physical space, the basis bivectors are {e₁e₂, e₁e₃, e₂e₃}. The sign of the <code>BitIndex{Q}</code> is negative when the parity of the basis vector permutation is odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindex.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.BitIndices" href="#CliffordNumbers.BitIndices"><code>CliffordNumbers.BitIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BitIndices{Q&lt;:QuadraticForm,C&lt;:AbstractCliffordNumber{Q,&lt;:Any}} &lt;: AbstractVector{BitIndex{Q}}</code></pre><p>Represents a range of valid <code>BitIndex</code> objects for the nonzero components of a given multivector  with quadratic form <code>Q</code>.</p><p>For a generic <code>AbstractCliffordNumber{Q}</code>, this returns <code>BitIndices{CliffordNumber{Q}}</code>, which contains all possible indices for a multivector associated with the quadratic form <code>Q</code>. This may  also be constructed with <code>BitIndices(Q)</code>.</p><p>For sparse representations, such as <code>KVector{K,Q}</code>, the object only contains the indices of the nonzero elements of the multivector.</p><p><strong>Construction</strong></p><p><code>BitIndices</code> can be constructed by calling the type constructor with either the multivector or its type.</p><p><strong>Indexing</strong></p><p><code>BitIndices</code> always uses one-based indexing like most Julia arrays. Although it is more natural in the dense case to use zero-based indexing, as the basis blades are naturally encoded in the indices for the dense representation of <code>CliffordNumber</code>, one-based indexing is used by the tuples which contain the data associated with this package&#39;s implementations of Clifford numbers.</p><p><strong>Interfaces for new subtypes of <code>AbstractCliffordNumber</code></strong></p><p>When defining the behavior of <code>BitIndices</code> for new subtypes <code>T</code> of <code>AbstractCliffordNumber</code>,  <code>Base.getindex(::BitIndices{Q,T}, i::Integer)</code> should be defined so that all indices of T that are not constrained to be zero are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindices.jl#L26-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.CliffordNumber" href="#CliffordNumbers.CliffordNumber"><code>CliffordNumbers.CliffordNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumber{Q,T,L} &lt;: AbstractCliffordNumber{Q,T}</code></pre><p>A dense multivector (or Clifford number), with quadratic form <code>Q</code>, element type <code>T</code>, and length <code>L</code> (which depends entirely on <code>Q</code>).</p><p>The coefficients are ordered by taking advantage of the natural binary structure of the basis. The grade of an element is given by the Hamming weight of its index. For the algebra of physical space, the order is: 1, e₁, e₂, e₁₂, e₃, e₁₃, e₂₃, e₁₂₃ = i. This order allows for more aggressive SIMD optimization when calculating the geometric product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/cliffordnumber.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.KVector" href="#CliffordNumbers.KVector"><code>CliffordNumbers.KVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KVector{K,Q,T,L} &lt;: AbstractCliffordNumber{Q,T}</code></pre><p>A multivector consisting only linear combinations of basis blades of grade <code>K</code> - in other words, a k-vector.</p><p>k-vectors have <code>binomial(dimension(Q), K)</code> components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/kvector.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.QFComplex" href="#CliffordNumbers.QFComplex"><code>CliffordNumbers.QFComplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.QFComplex</code></pre><p>The quadratic form with one dimension squaring to -1, <code>QuadraticForm{0,1,0}</code>. This generates a Clifford algebra isomorphic to the complex numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/quadratic.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.QFReal" href="#CliffordNumbers.QFReal"><code>CliffordNumbers.QFReal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.QFComplex</code></pre><p>The quadratic form with zero dimensions, <code>QuadraticForm{0,0,0}</code>, isomorphic to the real numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/quadratic.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.QuadraticForm" href="#CliffordNumbers.QuadraticForm"><code>CliffordNumbers.QuadraticForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.QuadratricForm</code></pre><p>Represents a quadratric with <code>P</code> dimensions which square to +1, <code>Q</code> dimensions which square to -1, and <code>R</code> dimensions which square to 0, in that order.</p><p>By convention, this type is used as a tag, and is never instantiated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/quadratic.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.RepresentedGrades" href="#CliffordNumbers.RepresentedGrades"><code>CliffordNumbers.RepresentedGrades</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RepresentedGrades{C&lt;:AbstractCliffordNumber} &lt;: AbstractVector{Bool}</code></pre><p>A vector describing the grades explicitly represented by some Clifford number type <code>C</code>.</p><p>Indexing of a <code>RepresentedGrades{Q}</code> is zero-based, with indices corresponding to all grades from 0 (scalar) to <code>dimension(Q)</code> (pseudoscalar), with <code>true</code> values indicating nonzero grades, and <code>false</code> indicating that the grade is zero.</p><p><strong>Implementation</strong></p><p>The function <code>nonzero_grades(::Type{T})</code> should be implemented for types <code>T</code> descending from  <code>AbstractCliffordNumber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/grades.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.STA" href="#CliffordNumbers.STA"><code>CliffordNumbers.STA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">STA</code></pre><p>Spacetime algebra with a mostly negative signature (particle physicist&#39;s convention), Cl(1,3,0). An alias for <code>QuadraticForm{1,3,0}</code>.</p><p>The negative signature is used by default to distinguish this algebra from conformal geometric algebras, which use a mostly positive signature by convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/quadratic.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.TransformedBitIndices" href="#CliffordNumbers.TransformedBitIndices"><code>CliffordNumbers.TransformedBitIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransformedBitIndices{Q,C,F} &lt;: AbstractBitIndices{Q,C}</code></pre><p>Lazy representation of <code>BitIndices{Q,C}</code> with some function of type <code>f</code> applied to each element. These objects can be used to perform common operations which act on basis blades or grades, such as the reverse or grade involution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindices.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.Z2CliffordNumber" href="#CliffordNumbers.Z2CliffordNumber"><code>CliffordNumbers.Z2CliffordNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.Z2CliffordNumber{P,Q,T,L}</code></pre><p>A Clifford number whose only nonzero grades are even or odd. Clifford numbers of this form naturally arise as versors, the geometric product of 1-vectors.</p><p>The type parameter <code>P</code> is constrained to be a <code>Bool</code>: <code>true</code> for odd grade Clifford numbers, and <code>false</code> for even grade Clifford numbers, corresponding to the Boolean result of each grade modulo 2.</p><p><strong>Type aliases</strong></p><p>This type is not exported, and usually you will want to refer to the following aliases:</p><pre><code class="nohighlight hljs">const EvenCliffordNumber{Q,T,L} = Z2CliffordNumber{false,Q,T,L}
const OddCliffordNumber{Q,T,L} = Z2CliffordNumber{true,Q,T,L}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/even.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q" href="#Base.:*-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})
(x::AbstractCliffordNumber{Q})(y::AbstractCliffordNumber{Q})</code></pre><p>Calculates the geometric product of <code>x</code> and <code>y</code>, returning the smallest type which is able to represent all nonzero basis blades of the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L154-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs-Tuple{AbstractCliffordNumber}" href="#Base.abs-Tuple{AbstractCliffordNumber}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs2(x::CliffordNumber{Q,T}) -&gt; Union{Real,Complex}</code></pre><p>Calculates the norm of <code>x</code>, equal to <code>sqrt(scalar_product(x, ~x))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L188-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs2-Tuple{AbstractCliffordNumber}" href="#Base.abs2-Tuple{AbstractCliffordNumber}"><code>Base.abs2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs2(x::AbstractCliffordNumber{Q,T}) -&gt; T</code></pre><p>Calculates the squared norm of <code>x</code>, equal to <code>scalar_product(x, ~x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{BitIndex}" href="#Base.conj-Tuple{BitIndex}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conj(b::BitIndex) -&gt; BitIndex
conj(x::AbstractCliffordNumber{Q,T}) -&gt; typeof(x)</code></pre><p>Calculates the Clifford conjugate of the basis blade indexed by <code>b</code> or the Clifford number <code>x</code>. This is equal to <code>grade_involution(reverse(x))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindex.jl#L145-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{CliffordNumber}" href="#Base.exp-Tuple{CliffordNumber}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(x::CliffordNumber{Q}) -&gt; CliffordNumber{Q,&lt;:AbstractFloat}</code></pre><p>Returns the natural exponential of a Clifford number.</p><p>For special cases where m squares to a scalar, the following shortcuts can be used to calculate <code>exp(x)</code>:</p><ul><li>When x^2 &lt; 0: <code>exp(x) === cos(abs(x)) + x * sin(abs(x)) / abs(x)</code></li><li>When x^2 &gt; 0: <code>exp(x) === cosh(abs(x)) + x * sinh(abs(x)) / abs(x)</code></li><li>When x^2 === 0: <code>exp(x) == 1 + x</code></li></ul><p>See also: <a href="#CliffordNumbers.exppi-Tuple{CliffordNumber}"><code>exppi</code></a>, <a href="#CliffordNumbers.exptau-Tuple{CliffordNumber}"><code>exptau</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L431-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.real-Union{Tuple{AbstractCliffordNumber{Q, &lt;:Real}}, Tuple{Q}} where Q" href="#Base.real-Union{Tuple{AbstractCliffordNumber{Q, &lt;:Real}}, Tuple{Q}} where Q"><code>Base.real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real(x::CliffordNumber{Q,T&lt;:Real}) = T</code></pre><p>Return the real (scalar) portion of a real Clifford number. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse-Tuple{BitIndex}" href="#Base.reverse-Tuple{BitIndex}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse(b::BitIndex) -&gt; BitIndex
reverse(x::AbstractCliffordNumber{Q,T}) -&gt; typeof(x)</code></pre><p>Performs the reverse operation on the basis blade indexed by <code>b</code> or the Clifford number <code>x</code>. The  sign of the reverse depends on the grade, and is positive for <code>g % 4 in 0:1</code> and negative for <code>g % 4 in 2:3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindex.jl#L125-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{Type{QuadraticForm{P, Q, R}}, Integer}} where {P, Q, R}" href="#Base.sign-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{Type{QuadraticForm{P, Q, R}}, Integer}} where {P, Q, R}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(::Type{QuadraticForm{P,Q,R}}, i::Integer) -&gt; Int8</code></pre><p>Gets the sign associated with dimension <code>i</code> of a quadratric form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/quadratic.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.CGA-Tuple{Any}" href="#CliffordNumbers.CGA-Tuple{Any}"><code>CliffordNumbers.CGA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CGA(D) -&gt; Type{QuadraticForm{D+1,1,0}}</code></pre><p>Creates the type of a quadratic form associated with a conformal geometric algebra (CGA) of dimension <code>D</code>.</p><p>For reasons of type stability, avoid calling this function without constant arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/quadratic.jl#L84-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.PGA-Tuple{Any}" href="#CliffordNumbers.PGA-Tuple{Any}"><code>CliffordNumbers.PGA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PGA(D) -&gt; Type{QuadraticForm{D,0,1}}</code></pre><p>Creates the type of a quadratic form associated with a projective geometric algebra (PGA) of dimension <code>D</code>.</p><p>For reasons of type stability, avoid calling this function without constant arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/quadratic.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.VGA-Tuple{Any}" href="#CliffordNumbers.VGA-Tuple{Any}"><code>CliffordNumbers.VGA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VGA(D) -&gt; Type{QuadraticForm{D,0,0}}</code></pre><p>Creates the type of a quadratic form associated with a vector/vanilla geometric algebra (VGA) of dimension <code>D</code>.</p><p>For reasons of type stability, avoid calling this function without constant arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/quadratic.jl#L64-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers._sort_with_parity!-Tuple{AbstractVector{&lt;:Real}}" href="#CliffordNumbers._sort_with_parity!-Tuple{AbstractVector{&lt;:Real}}"><code>CliffordNumbers._sort_with_parity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers._sort_with_parity!(v::AbstractVector{&lt;:Real}) -&gt; Tuple{typeof(v),Bool}</code></pre><p>Performs a parity-tracking insertion sort of <code>v</code>, which modifies <code>v</code> in place. The function returns a tuple containing <code>v</code> and the parity, which is <code>true</code> for an odd permutation and <code>false</code> for an even permutation. This is implemented with a modified insertion sort algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindex.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.check_element_count-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Any, Type{QuadraticForm{X, Y, Z}}, Any}} where {X, Y, Z}" href="#CliffordNumbers.check_element_count-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Any, Type{QuadraticForm{X, Y, Z}}, Any}} where {X, Y, Z}"><code>CliffordNumbers.check_element_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.check_element_count(f, Q::Type{&lt;:QuadraticForm}, [L,] data)</code></pre><p>Ensures that the number of elements in <code>data</code> is the same as the result of <code>f(Q)</code>, where <code>f</code> is a function that generates the expected number of elements for the type. This function is used in the inner constructors of subtypes of <code>AbstractCliffordNumber{Q}</code> to ensure that the input has the correct length.</p><p>If provided, the length type parameter <code>L</code> can be included as an argument, and it will be checked for type (must be an <code>Int</code>) and value (must be equal to <code>f(Q)</code>).</p><p>This function returns nothing, but throws an <code>AssertionError</code> for failed checks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/abstract.jl#L93-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.commutator-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q" href="#CliffordNumbers.commutator-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q"><code>CliffordNumbers.commutator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">commutator(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})
×(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})</code></pre><p>Calculates the commutator product, equal to <code>1//2 * (x*y - y*x)</code>, or equivalently,  <code>1//2 * (x*y - reverse(x*y))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L348-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.dot-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#CliffordNumbers.dot-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(x::CliffordNumber{Q}, y::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Calculates the dot product of <code>x</code> and <code>y</code>.</p><p>For basis blades <code>A</code> of grade <code>m</code> and <code>B</code> of grade <code>n</code>, the dot product is equal to the left contraction when <code>m &gt;= n</code> and is equal to the right contraction when <code>n &gt;= m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L284-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.dual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q" href="#CliffordNumbers.dual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q"><code>CliffordNumbers.dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual(x::CliffordNumber) -&gt; CliffordNumber</code></pre><p>Calculates the dual of <code>x</code>, which is equal to the left contraction of <code>x</code> with the inverse of the pseudoscalar. However, </p><p>Note that the dual has some properties that depend on the dimension and quadratic form:</p><ul><li>The inverse of the unit pseudoscalar depends on the dimension of the space. Therefore, the</li></ul><p>periodicity of </p><ul><li>If the metric is degenerate, the dual is not unique.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L363-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.elementwise_product-Union{Tuple{C}, Tuple{Q}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}, Bool}} where {Q, C&lt;:(AbstractCliffordNumber{Q})}" href="#CliffordNumbers.elementwise_product-Union{Tuple{C}, Tuple{Q}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}, Bool}} where {Q, C&lt;:(AbstractCliffordNumber{Q})}"><code>CliffordNumbers.elementwise_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.elementwise_product(
    [::Type{C},]
    x::AbstractCliffordNumber{Q},
    y::AbstractCliffordNumber{Q},
    a::BitIndex{Q},
    b::BitIndex{Q},
    [condition = true]
) where {Q,T&lt;:AbstractCliffordNumber{Q}} -&gt; C</code></pre><p>Calculates the geometric product between the element of <code>x</code> indexed by <code>a</code> and the element of <code>y</code> indexed by <code>b</code>. The result is returned as type <code>C</code>, but this can be inferred automatically if not provided.</p><p>An optional boolean condition can be provided, which simplifies the implementation of certain products derived from the geometric product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L97-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.evil_number-Tuple{Integer}" href="#CliffordNumbers.evil_number-Tuple{Integer}"><code>CliffordNumbers.evil_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.evil_number(n::Integer)</code></pre><p>Returns the nth evil number, with the first evil number (<code>n == 1</code>) defined to be 0.</p><p>Evil numbers are numbers which have an even Hamming weight (sum of its binary digits).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/hamming.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.exppi-Tuple{CliffordNumber}" href="#CliffordNumbers.exppi-Tuple{CliffordNumber}"><code>CliffordNumbers.exppi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exppi(x::CliffordNumber)</code></pre><p>Returns the natural exponential of <code>π * x</code> with greater accuracy than <code>exp(π * x)</code> in the case where <code>x^2</code> is a negative scalar.</p><p>See also: <a href="#Base.exp-Tuple{CliffordNumber}"><code>exp</code></a>, <a href="#CliffordNumbers.exptau-Tuple{CliffordNumber}"><code>exptau</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L458-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.exptau-Tuple{CliffordNumber}" href="#CliffordNumbers.exptau-Tuple{CliffordNumber}"><code>CliffordNumbers.exptau</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exptau(x::CliffordNumber)</code></pre><p>Returns the natural exponential of <code>2π * x</code> with greater accuracy than <code>exp(2π * x)</code> in the case where <code>x^2</code> is a negative scalar.</p><p>See also: <a href="#Base.exp-Tuple{CliffordNumber}"><code>exp</code></a>, <a href="#CliffordNumbers.exppi-Tuple{CliffordNumber}"><code>exppi</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L481-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.grade_involution-Tuple{BitIndex}" href="#CliffordNumbers.grade_involution-Tuple{BitIndex}"><code>CliffordNumbers.grade_involution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grade_involution(b::BitIndex) -&gt; BitIndex
grade_involution(x::AbstractCliffordNumber{Q,T}) -&gt; typeof(x)</code></pre><p>Calculates the grade involution of the basis blade indexed by <code>b</code> or the Clifford number <code>x</code>. This effectively reflects all of the basis vectors of the space along their own mirror operation, which makes elements of odd grade flip sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindex.jl#L135-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.hamming_number-Tuple{Integer, Integer}" href="#CliffordNumbers.hamming_number-Tuple{Integer, Integer}"><code>CliffordNumbers.hamming_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.hamming_number(w::Integer, n::Integer)</code></pre><p>Gets the <code>n</code>th number with Hamming weight <code>w</code>. The first number with this Hamming weight (<code>n = 1</code>) is <code>2^w - 1</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; CliffordNumbers.hamming_number(3, 2)
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/hamming.jl#L55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.has_grades_of-Tuple{Type{&lt;:AbstractCliffordNumber}, Type{&lt;:AbstractCliffordNumber}}" href="#CliffordNumbers.has_grades_of-Tuple{Type{&lt;:AbstractCliffordNumber}, Type{&lt;:AbstractCliffordNumber}}"><code>CliffordNumbers.has_grades_of</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_grades_of(S::Type{&lt;:AbstractCliffordNumber}, T::Type{&lt;:AbstractCliffordNumber}) -&gt; Bool
has_grades_of(x::AbstractCliffordNumber, y::AbstractCliffordNumber) -&gt; Bool</code></pre><p>Returns <code>true</code> if the grades represented in S are also represented in T; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/grades.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.has_wedge-Union{Tuple{Q}, Tuple{BitIndex{Q}, BitIndex{Q}}} where Q" href="#CliffordNumbers.has_wedge-Union{Tuple{Q}, Tuple{BitIndex{Q}, BitIndex{Q}}} where Q"><code>CliffordNumbers.has_wedge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.has_wedge(a::BitIndex{Q}, b::BitIndex{Q}) -&gt; Bool</code></pre><p>Returns <code>true</code> if the basis blades indexed by <code>a</code> and <code>b</code> may have a nonzero wedge product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindex.jl#L221-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.hestenes_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#CliffordNumbers.hestenes_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.hestenes_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hestenes_product(x::CliffordNumber{Q}, y::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Returns the Hestenes product: this is equal to the dot product given by <code>dot(x, y)</code> but is equal to to zero when either <code>x</code> or <code>y</code> is a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L304-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.isevil-Tuple{Integer}" href="#CliffordNumbers.isevil-Tuple{Integer}"><code>CliffordNumbers.isevil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.isevil(i::Integer) -&gt; Bool</code></pre><p>Determines whether a number is evil, meaning that its Hamming weight (sum of its binary digits) is even.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/hamming.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.isodious-Tuple{Integer}" href="#CliffordNumbers.isodious-Tuple{Integer}"><code>CliffordNumbers.isodious</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.isodious(i::Integer) -&gt; Bool</code></pre><p>Determines whether a number is odious, meaning that its Hamming weight (sum of its binary digits) is odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/hamming.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.ispseudoscalar-Tuple{CliffordNumber}" href="#CliffordNumbers.ispseudoscalar-Tuple{CliffordNumber}"><code>CliffordNumbers.ispseudoscalar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispseudoscalar(m::CliffordNumber)</code></pre><p>Determines whether the Clifford number <code>m</code> is a pseudoscalar, meaning that it has no components with grades below the one equal to the dimension of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/cliffordnumber.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.isscalar-Tuple{CliffordNumber}" href="#CliffordNumbers.isscalar-Tuple{CliffordNumber}"><code>CliffordNumbers.isscalar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isscalar(m::CliffordNumber)</code></pre><p>Determines whether the Clifford number <code>m</code> is a scalar, meaning that it has no components with grades above zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/cliffordnumber.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.next_of_hamming_weight-Tuple{Integer}" href="#CliffordNumbers.next_of_hamming_weight-Tuple{Integer}"><code>CliffordNumbers.next_of_hamming_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.next_of_hamming_weight(n::Integer)</code></pre><p>Returns the next integer with the same Hamming weight as <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/hamming.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.nonzero_grades-Tuple{Number}" href="#CliffordNumbers.nonzero_grades-Tuple{Number}"><code>CliffordNumbers.nonzero_grades</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonzero_grades(::Type{&lt;:AbstractCliffordNumber})
nonzero_grades(::AbstractCliffordNumber)</code></pre><p>A function returning an indexable object representing all nonzero grades of a Clifford number representation.</p><p>This function is used to define the indexing of <code>RepresentedGrades</code>, and should be defined for any subtypes of <code>AbstractCliffordNumber</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; CliffordNumbers.nonzero_grades(CliffordNumber{APS})
0:3

julia&gt; CliffordNumbers.nonzero_grades(KVector{2,APS})
2:2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/grades.jl#L25-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.normalize-Tuple{AbstractCliffordNumber}" href="#CliffordNumbers.normalize-Tuple{AbstractCliffordNumber}"><code>CliffordNumbers.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize(x::AbstractCliffordNumber{Q}) -&gt; AbstractCliffordNumber{Q}</code></pre><p>Normalizes <code>x</code> so that its magnitude (as calculated by <code>abs2(x)</code>) is 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.number_of_parity-Tuple{Integer, Bool}" href="#CliffordNumbers.number_of_parity-Tuple{Integer, Bool}"><code>CliffordNumbers.number_of_parity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.number_of_parity(n::Integer, modulo::Bool)</code></pre><p>Returns the nth number whose Hamming weight is even (for <code>modulo = false</code>) or odd (for <code>modulo = true</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/hamming.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.numeric_type-Tuple{Type}" href="#CliffordNumbers.numeric_type-Tuple{Type}"><code>CliffordNumbers.numeric_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">numeric_type(::Type{&lt;:AbstractCliffordNumber{Q,T}}) = T
numeric_type(T::Type{&lt;:Union{Real,Complex}}) = T
numeric_type(x) = numeric_type(typeof(x))</code></pre><p>Returns the numeric type associated with an <code>AbstractCliffordNumber</code> instance. For subtypes of <code>Real</code> and <code>Complex</code>, or their instances, this simply returns the input type or instance type.</p><p><strong>Why not define <code>eltype</code>?</strong></p><p><code>AbstractCliffordNumber</code> instances behave like numbers, not arrays. If <code>collect()</code> is called on a Clifford number of type <code>T</code>, it should not construct a vector of coefficients; instead it should return an <code>Array{T,0}</code>. Similarly, a broadcasted multiplication should return the same result as normal multiplication, as is the case with complex numbers.</p><p>For subtypes <code>T</code> of <code>Number</code>, <code>eltype(T) === T</code>, and this is true for <code>AbstractCliffordNumber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/abstract.jl#L34-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.odious_number-Tuple{Integer}" href="#CliffordNumbers.odious_number-Tuple{Integer}"><code>CliffordNumbers.odious_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.odious_number(n::Integer)</code></pre><p>Returns the nth odious number, with the first odious number (<code>n == 1</code>) defined to be 1.</p><p>Odious numbers are numbers which have an odd Hamming weight (sum of its binary digits).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/hamming.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.promote_numeric_type-Tuple{}" href="#CliffordNumbers.promote_numeric_type-Tuple{}"><code>CliffordNumbers.promote_numeric_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote_numeric_type(x, y)</code></pre><p>Calls <code>promote_type()</code> for the result of <code>numeric_type()</code> called on all arguments. For incompletely specified types, the result of <code>numeric_type()</code> is replaced with <code>Bool</code>, which always promotes to any larger numeric type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/promote.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.sandwich-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#CliffordNumbers.sandwich-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.sandwich</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sandwich(x::CliffordNumber{Q}, y::CliffordNumber{Q})</code></pre><p>Calculates the sandwich product of <code>x</code> with <code>y</code>: <code>~y * x * y</code>, but with corrections for numerical stability. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L402-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.scalar_product-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q" href="#CliffordNumbers.scalar_product-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q"><code>CliffordNumbers.scalar_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scalar_product(x::CliffordNumber{Q,T1}, y::CliffordNumber{Q,T2}) -&gt; promote_type(T1,T2)</code></pre><p>Calculates the scalar product of two Clifford numbers with quadratic form <code>Q</code>. The result is a <code>Real</code> or <code>Complex</code> number. This can be converted back to an <code>AbstractCliffordNumber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L169-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.select_grade-Tuple{CliffordNumber, Integer}" href="#CliffordNumbers.select_grade-Tuple{CliffordNumber, Integer}"><code>CliffordNumbers.select_grade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_grade(x::CliffordNumber, g::Integer)</code></pre><p>Returns a multivector similar to <code>x</code> where all elements not of grade <code>g</code> are equal to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.sign_of_mult-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{BitIndex{QuadraticForm{P, Q, R}}, BitIndex{QuadraticForm{P, Q, R}}}} where {P, Q, R}" href="#CliffordNumbers.sign_of_mult-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{BitIndex{QuadraticForm{P, Q, R}}, BitIndex{QuadraticForm{P, Q, R}}}} where {P, Q, R}"><code>CliffordNumbers.sign_of_mult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.sign_of_mult(a::T, b::T) where T&lt;:BitIndex{QuadraticForm{P,Q,R}} -&gt; Int8</code></pre><p>Returns an <code>Int8</code> that carries the sign associated with the multiplication of two basis blades of Clifford/geometric algebras of the same quadratic form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindex.jl#L194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.signbit_of_mult-Tuple{Unsigned, Unsigned}" href="#CliffordNumbers.signbit_of_mult-Tuple{Unsigned, Unsigned}"><code>CliffordNumbers.signbit_of_mult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.signbit_of_mult(a::Integer, [b::Integer]) -&gt; Bool
CliffordNumbers.signbit_of_mult(a::BitIndex, [b::BitIndex]) -&gt; Bool</code></pre><p>Calculates the sign bit associated with multiplying basis elements indexed with bit indices supplied as either integers or <code>BitIndex</code> instances. The sign bit flips when the order of <code>a</code> and <code>b</code> are reversed, unless <code>a === b</code>. </p><p>As with <code>Base.signbit()</code>, <code>true</code> represents a negative sign and <code>false</code> a positive sign. However, in degenerate metrics (such as those of projective geometric algebras) the sign bit may be irrelevant as the multiplication of those basis blades would result in zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindex.jl#L155-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.signmask" href="#CliffordNumbers.signmask"><code>CliffordNumbers.signmask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.signmask(T::Type{&lt;:Integer}, signbit::Bool = true) -&gt; T1</code></pre><p>Generates a signmask, or a string of bits where the only 1 bit is the sign bit. If <code>signbit</code> is set to false, this returns a string of bits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/bitindex.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.similar_type-Tuple{AbstractCliffordNumber, Type{&lt;:Union{Real, Complex}}, Type{&lt;:QuadraticForm}}" href="#CliffordNumbers.similar_type-Tuple{AbstractCliffordNumber, Type{&lt;:Union{Real, Complex}}, Type{&lt;:QuadraticForm}}"><code>CliffordNumbers.similar_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.similar_type(
    C::Type{&lt;:AbstractCliffordNumber},
    [N::Type{&lt;:BaseNumber} = numeric_type(C)],
    [Q::Type{&lt;:QuadraticForm} = QuadraticForm(C)]
) -&gt; Type{&lt;:AbstractCliffordNumber{Q,N}}</code></pre><p>Constructs a type similar to <code>T</code> but with numeric type <code>N</code> and quadratic form <code>Q</code>.</p><p>This function must be defined with all its arguments for each concrete type subtyping <code>AbstractCliffordNumber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/abstract.jl#L70-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.subscript_string-Tuple{Number}" href="#CliffordNumbers.subscript_string-Tuple{Number}"><code>CliffordNumbers.subscript_string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.subscript_string(x::Number) -&gt; String</code></pre><p>Produces a string representation of a number in subscript format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/CliffordNumbers.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.to_basis_str-Union{Tuple{BitIndex{Q}}, Tuple{Q}} where Q" href="#CliffordNumbers.to_basis_str-Union{Tuple{BitIndex{Q}}, Tuple{Q}} where Q"><code>CliffordNumbers.to_basis_str</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.to_basis_str(b::BitIndex; [label], [pseudoscalar])</code></pre><p>Creates a string representation of the basis element given by <code>b</code>.</p><p>The <code>label</code> parameter determines the symbol used for every basis element. In general, this defaults to <code>e</code>, but a few special cases use different symbols:</p><ul><li>For the algebra of physical space, <code>σ</code> is used.</li><li>For the spacetime algebras of either signature, <code>γ</code> is used.</li></ul><p>If <code>pseudoscalar</code> is set, the pseudoscalar may be printed using a different symbol from the rest of the basis elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/show.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.undual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q" href="#CliffordNumbers.undual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q"><code>CliffordNumbers.undual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">undual(x::CliffordNumber) -&gt; CliffordNumber</code></pre><p>Calculates the undual of <code>x</code>, which is equal to the left contraction of <code>x</code> with the pseudoscalar. This function can be used to reverse the behavior of <code>dual()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L378-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.versor_inverse-Tuple{CliffordNumber}" href="#CliffordNumbers.versor_inverse-Tuple{CliffordNumber}"><code>CliffordNumbers.versor_inverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">versor_inverse(x::CliffordNumber)</code></pre><p>Calculates the versor inverse of <code>x</code>, equal to <code>x / scalar_product(x, ~x)</code>, so that <code>x * inv(x) == inv(x) * x == 1</code>.</p><p>The versor inverse is only guaranteed to be an inverse for blades and versors. Not all Clifford numbers have a well-defined inverse, since Clifford numbers have zero divisors (for instance, in the algebra of physical space, 1 + e₁ has a zero divisor).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L389-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.wedge-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q" href="#CliffordNumbers.wedge-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q"><code>CliffordNumbers.wedge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wedge(x::CliffordNumber{Q}, y::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Calculates the wedge (outer) product of two Clifford numbers <code>x</code> and <code>y</code> with quadratic form <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/e882a7b84264f690a7072635c813f5a80e6cc7ed/src/math.jl#L328-L332">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 27 February 2024 03:32">Tuesday 27 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
