<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CliffordNumbers.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://brainandforce.github.io/CliffordNumbers.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CliffordNumbers.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CliffordNumbers"><a class="docs-heading-anchor" href="#CliffordNumbers">CliffordNumbers</a><a id="CliffordNumbers-1"></a><a class="docs-heading-anchor-permalink" href="#CliffordNumbers" title="Permalink"></a></h1><p><a href="https://github.com/brainandforce/CliffordNumbers.jl">CliffordNumbers.jl</a> is a package that provides fully static multivectors (Clifford numbers) in arbitrary dimensions and metrics. While in many cases, sparse representations of multivectors are more efficient, for spaces of low dimension, dense static representations may provide a performance and convenience advantage.</p><ul><li><a href="#CliffordNumbers.APS"><code>CliffordNumbers.APS</code></a></li><li><a href="#CliffordNumbers.AbstractCliffordNumber"><code>CliffordNumbers.AbstractCliffordNumber</code></a></li><li><a href="#CliffordNumbers.BaseNumber"><code>CliffordNumbers.BaseNumber</code></a></li><li><a href="#CliffordNumbers.BitIndex"><code>CliffordNumbers.BitIndex</code></a></li><li><a href="#CliffordNumbers.BitIndex-Union{Tuple{Vararg{Integer}}, Tuple{Q}} where Q"><code>CliffordNumbers.BitIndex</code></a></li><li><a href="#CliffordNumbers.BitIndices-Union{Tuple{Type{&lt;:AbstractCliffordNumber{Q}}}, Tuple{Q}} where Q"><code>CliffordNumbers.BitIndices</code></a></li><li><a href="#CliffordNumbers.BitIndices"><code>CliffordNumbers.BitIndices</code></a></li><li><a href="#CliffordNumbers.CliffordNumber"><code>CliffordNumbers.CliffordNumber</code></a></li><li><a href="#CliffordNumbers.KVector"><code>CliffordNumbers.KVector</code></a></li><li><a href="#CliffordNumbers.QuadraticForm"><code>CliffordNumbers.QuadraticForm</code></a></li><li><a href="#CliffordNumbers.STA"><code>CliffordNumbers.STA</code></a></li><li><a href="#Base.:*-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>Base.:*</code></a></li><li><a href="#Base.:~-Tuple{CliffordNumber}"><code>Base.:~</code></a></li><li><a href="#Base.abs-Tuple{CliffordNumber}"><code>Base.abs</code></a></li><li><a href="#Base.abs2-Tuple{CliffordNumber}"><code>Base.abs2</code></a></li><li><a href="#Base.conj-Tuple{CliffordNumber}"><code>Base.conj</code></a></li><li><a href="#Base.exp-Tuple{CliffordNumber}"><code>Base.exp</code></a></li><li><a href="#Base.real-Tuple{CliffordNumber{&lt;:QuadraticForm, &lt;:Real}}"><code>Base.real</code></a></li><li><a href="#Base.reverse-Tuple{CliffordNumber}"><code>Base.reverse</code></a></li><li><a href="#Base.sign-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{Type{QuadraticForm{P, Q, R}}, Integer}} where {P, Q, R}"><code>Base.sign</code></a></li><li><a href="#CliffordNumbers.CGA-Tuple{Any}"><code>CliffordNumbers.CGA</code></a></li><li><a href="#CliffordNumbers.PGA-Tuple{Any}"><code>CliffordNumbers.PGA</code></a></li><li><a href="#CliffordNumbers.VGA-Tuple{Any}"><code>CliffordNumbers.VGA</code></a></li><li><a href="#CliffordNumbers._sort_with_parity!-Tuple{AbstractVector{&lt;:Real}}"><code>CliffordNumbers._sort_with_parity!</code></a></li><li><a href="#CliffordNumbers.dot-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.dot</code></a></li><li><a href="#CliffordNumbers.dual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q"><code>CliffordNumbers.dual</code></a></li><li><a href="#CliffordNumbers.elementwise_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}}} where Q"><code>CliffordNumbers.elementwise_product</code></a></li><li><a href="#CliffordNumbers.evil_number-Tuple{Integer}"><code>CliffordNumbers.evil_number</code></a></li><li><a href="#CliffordNumbers.exppi-Tuple{CliffordNumber}"><code>CliffordNumbers.exppi</code></a></li><li><a href="#CliffordNumbers.exptau-Tuple{CliffordNumber}"><code>CliffordNumbers.exptau</code></a></li><li><a href="#CliffordNumbers.grade_involution-Tuple{CliffordNumber}"><code>CliffordNumbers.grade_involution</code></a></li><li><a href="#CliffordNumbers.hamming_number-Tuple{Integer, Integer}"><code>CliffordNumbers.hamming_number</code></a></li><li><a href="#CliffordNumbers.hestenes_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.hestenes_product</code></a></li><li><a href="#CliffordNumbers.isevil-Tuple{Integer}"><code>CliffordNumbers.isevil</code></a></li><li><a href="#CliffordNumbers.isodious-Tuple{Integer}"><code>CliffordNumbers.isodious</code></a></li><li><a href="#CliffordNumbers.ispseudoscalar-Tuple{CliffordNumber}"><code>CliffordNumbers.ispseudoscalar</code></a></li><li><a href="#CliffordNumbers.isscalar-Tuple{CliffordNumber}"><code>CliffordNumbers.isscalar</code></a></li><li><a href="#CliffordNumbers.left_contraction-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.left_contraction</code></a></li><li><a href="#CliffordNumbers.normalize-Tuple{CliffordNumber}"><code>CliffordNumbers.normalize</code></a></li><li><a href="#CliffordNumbers.odious_number-Tuple{Integer}"><code>CliffordNumbers.odious_number</code></a></li><li><a href="#CliffordNumbers.right_contraction-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.right_contraction</code></a></li><li><a href="#CliffordNumbers.sandwich-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.sandwich</code></a></li><li><a href="#CliffordNumbers.scalar_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.scalar_product</code></a></li><li><a href="#CliffordNumbers.select_grade-Tuple{CliffordNumber, Integer}"><code>CliffordNumbers.select_grade</code></a></li><li><a href="#CliffordNumbers.sign_of_mult-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{BitIndex{QuadraticForm{P, Q, R}}, BitIndex{QuadraticForm{P, Q, R}}}} where {P, Q, R}"><code>CliffordNumbers.sign_of_mult</code></a></li><li><a href="#CliffordNumbers.signbit_of_mult-Tuple{Unsigned, Unsigned}"><code>CliffordNumbers.signbit_of_mult</code></a></li><li><a href="#CliffordNumbers.signmask"><code>CliffordNumbers.signmask</code></a></li><li><a href="#CliffordNumbers.subscript_string-Tuple{Number}"><code>CliffordNumbers.subscript_string</code></a></li><li><a href="#CliffordNumbers.undual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q"><code>CliffordNumbers.undual</code></a></li><li><a href="#CliffordNumbers.versor_inverse-Tuple{CliffordNumber}"><code>CliffordNumbers.versor_inverse</code></a></li><li><a href="#CliffordNumbers.wedge-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.wedge</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.BaseNumber" href="#CliffordNumbers.BaseNumber"><code>CliffordNumbers.BaseNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.BaseNumber</code></pre><p>Union of subtypes of <code>Number</code> provided in the Julia <code>Base</code> module: <code>Real</code> and <code>Complex</code>. This encompasses all types that may be used to construct a <code>CliffordNumber</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/CliffordNumbers.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.APS" href="#CliffordNumbers.APS"><code>CliffordNumbers.APS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">APS</code></pre><p>The algebra of physical space, Cl(3,0,0). An alias for <code>QuadraticForm{3,0,0}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/quadratic.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.AbstractCliffordNumber" href="#CliffordNumbers.AbstractCliffordNumber"><code>CliffordNumbers.AbstractCliffordNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCliffordNumber{Q,T}</code></pre><p>An element of a Clifford algebra, often referred to as a multivector, with quadratic form <code>Q</code> and element type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/numbers.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.BitIndex" href="#CliffordNumbers.BitIndex"><code>CliffordNumbers.BitIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BitIndex{Q&lt;:QuadraticForm}</code></pre><p>A representation of an index corresponding to a basis blade of the geometric algebra with quadratic form <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/bitindex.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.BitIndex-Union{Tuple{Vararg{Integer}}, Tuple{Q}} where Q" href="#CliffordNumbers.BitIndex-Union{Tuple{Vararg{Integer}}, Tuple{Q}} where Q"><code>CliffordNumbers.BitIndex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BitIndex{Q}(x::Integer...)
BitIndex{Q}(v::AbstractVector{&lt;:Integer})</code></pre><p>Constructs a <code>BitIndex{Q}</code> from a list of integers that represent the basis vectors of the space.</p><p>This package uses a lexicographic convention for basis blades: in the algebra of physical space, the basis bivectors are {e₁e₂, e₁e₃, e₂e₃}. The sign of the <code>BitIndex{Q}</code> is negative when the parity of the basis vector permutation is odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/bitindex.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.BitIndices" href="#CliffordNumbers.BitIndices"><code>CliffordNumbers.BitIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BitIndices{Q&lt;:QuadraticForm}</code></pre><p>Represents a range of valid <code>BitIndex</code> objects for a given quadratic form.</p><p>For sparse representations, such as <code>KVector{K...}</code>, this is not the most efficient way to iterate through all elements, as it includes indices that are known to be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/bitindex.jl#L203-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.BitIndices-Union{Tuple{Type{&lt;:AbstractCliffordNumber{Q}}}, Tuple{Q}} where Q" href="#CliffordNumbers.BitIndices-Union{Tuple{Type{&lt;:AbstractCliffordNumber{Q}}}, Tuple{Q}} where Q"><code>CliffordNumbers.BitIndices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BitIndices(x::AbstractCliffordNumber{Q}) -&gt; BitIndices{Q}()
BitIndices(T::Type{&lt;:AbstractCliffordNumber{Q}}) -&gt; BitIndices{Q}()</code></pre><p>Constructs a <code>BitIndices</code> object associated with a Clifford number or its type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/bitindex.jl#L214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.CliffordNumber" href="#CliffordNumbers.CliffordNumber"><code>CliffordNumbers.CliffordNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumber{Q,T,L}</code></pre><p>A dense multivector (or Clifford number), with quadratic form <code>Q</code>, element type <code>T</code>, and length <code>L</code> (which depends entirely on <code>Q</code>).</p><p>The coefficients are ordered by taking advantage of the natural binary structure of the basis. The grade of an element is given by the Hamming weight of its index. For the algebra of physical space, the order is: 1, e₁, e₂, e₁₂, e₃, e₁₃, e₂₃, e₁₂₃ = i. This order allows for more aggressive SIMD optimization when calculating the geometric product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/numbers.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.KVector" href="#CliffordNumbers.KVector"><code>CliffordNumbers.KVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KVector{K,Q,T,L}</code></pre><p>A multivector consisting only linear combinations of basis blades of grade <code>K</code> - in other words, a k-vector.</p><p>k-vectors have <code>binomial(dimension(Q), K)</code> components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/sparse/kvectors.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.QuadraticForm" href="#CliffordNumbers.QuadraticForm"><code>CliffordNumbers.QuadraticForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.QuadratricForm</code></pre><p>Represents a quadratric with <code>P</code> dimensions which square to +1, <code>Q</code> dimensions which square to -1, and <code>R</code> dimensions which square to 0, in that order.</p><p>By convention, this type is used as a tag, and is never instantiated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/quadratic.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.STA" href="#CliffordNumbers.STA"><code>CliffordNumbers.STA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">STA</code></pre><p>Spacetime algebra with a mostly negative signature (particle physicist&#39;s convention), Cl(1,3,0). An alias for <code>QuadraticForm{1,3,0}</code>.</p><p>The negative signature is used by default to distinguish this algebra from conformal geometric algebras, which use a mostly positive signature by convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/quadratic.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#Base.:*-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(x::CliffordNumber{Q}, y::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Calculates the geometric product between multivectors/Clifford numbers <code>x</code> and <code>y</code> which share the quadratic form <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:~-Tuple{CliffordNumber}" href="#Base.:~-Tuple{CliffordNumber}"><code>Base.:~</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse(x::CliffordNumber{Q,T}) -&gt; CliffordNumber{Q,T}
~(x::CliffordNumber{Q,T}) -&gt; CliffordNumber{Q,T}</code></pre><p>Calculate the reverse of a Clifford number. This effectively reverses the products that form the basis blades, or in other words, reverses the order of the geometric product that resulted in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs-Tuple{CliffordNumber}" href="#Base.abs-Tuple{CliffordNumber}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs2(x::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Calculates the norm of <code>x</code>, equal to <code>sqrt(scalar_product(x, ~x))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs2-Tuple{CliffordNumber}" href="#Base.abs2-Tuple{CliffordNumber}"><code>Base.abs2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs2(x::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Calculates the squared norm of <code>x</code>, equal to <code>scalar_product(x, ~x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{CliffordNumber}" href="#Base.conj-Tuple{CliffordNumber}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conj(x::CliffordNumber{Q,T}) -&gt; CliffordNumber{Q,T}</code></pre><p>Calculates the Clifford conjugate of a Clifford number <code>x</code>. This is equal to <code>grade_involution(reverse(x))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{CliffordNumber}" href="#Base.exp-Tuple{CliffordNumber}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(x::CliffordNumber{Q}) -&gt; CliffordNumber{Q,&lt;:AbstractFloat}</code></pre><p>Returns the natural exponential of a Clifford number.</p><p>For special cases where m squares to a scalar, the following shortcuts can be used to calculate <code>exp(x)</code>:</p><ul><li>When x^2 &lt; 0: <code>exp(x) === cos(abs(x)) + x * sin(abs(x)) / abs(x)</code></li><li>When x^2 &gt; 0: <code>exp(x) === cosh(abs(x)) + x * sinh(abs(x)) / abs(x)</code></li><li>When x^2 === 0: <code>exp(x) == 1 + x</code></li></ul><p>See also: <a href="#CliffordNumbers.exppi-Tuple{CliffordNumber}"><code>exppi</code></a>, <a href="#CliffordNumbers.exptau-Tuple{CliffordNumber}"><code>exptau</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L331-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.real-Tuple{CliffordNumber{&lt;:QuadraticForm, &lt;:Real}}" href="#Base.real-Tuple{CliffordNumber{&lt;:QuadraticForm, &lt;:Real}}"><code>Base.real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real(x::CliffordNumber{Q,T&lt;:Real}) = T</code></pre><p>Return the real (scalar) portion of a real Clifford number. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse-Tuple{CliffordNumber}" href="#Base.reverse-Tuple{CliffordNumber}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse(x::CliffordNumber{Q,T}) -&gt; CliffordNumber{Q,T}
~(x::CliffordNumber{Q,T}) -&gt; CliffordNumber{Q,T}</code></pre><p>Calculate the reverse of Clifford number <code>x</code>. This effectively reverses the products that form the basis blades, or in other words, reverses the order of the geometric product that resulted in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{Type{QuadraticForm{P, Q, R}}, Integer}} where {P, Q, R}" href="#Base.sign-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{Type{QuadraticForm{P, Q, R}}, Integer}} where {P, Q, R}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(::Type{QuadraticForm{P,Q,R}}, i::Integer) -&gt; Int8</code></pre><p>Gets the sign associated with dimension <code>i</code> of a quadratric form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/quadratic.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.CGA-Tuple{Any}" href="#CliffordNumbers.CGA-Tuple{Any}"><code>CliffordNumbers.CGA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CGA(D) -&gt; Type{QuadraticForm{D+1,1,0}}</code></pre><p>Creates the type of a quadratic form associated with a conformal geometric algebra (CGA) of dimension <code>D</code>.</p><p>For reasons of type stability, avoid calling this function without constant arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/quadratic.jl#L70-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.PGA-Tuple{Any}" href="#CliffordNumbers.PGA-Tuple{Any}"><code>CliffordNumbers.PGA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PGA(D) -&gt; Type{QuadraticForm{D,0,1}}</code></pre><p>Creates the type of a quadratic form associated with a projective geometric algebra (PGA) of dimension <code>D</code>.</p><p>For reasons of type stability, avoid calling this function without constant arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/quadratic.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.VGA-Tuple{Any}" href="#CliffordNumbers.VGA-Tuple{Any}"><code>CliffordNumbers.VGA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VGA(D) -&gt; Type{QuadraticForm{D,0,0}}</code></pre><p>Creates the type of a quadratic form associated with a vector/vanilla geometric algebra (VGA) of dimension <code>D</code>.</p><p>For reasons of type stability, avoid calling this function without constant arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/quadratic.jl#L50-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers._sort_with_parity!-Tuple{AbstractVector{&lt;:Real}}" href="#CliffordNumbers._sort_with_parity!-Tuple{AbstractVector{&lt;:Real}}"><code>CliffordNumbers._sort_with_parity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers._sort_with_parity!(v::AbstractVector{&lt;:Real}) -&gt; Tuple{typeof(v),Bool}</code></pre><p>Performs a parity-tracking insertion sort of <code>v</code>, which modifies <code>v</code> in place. The function returns a tuple containing <code>v</code> and the parity, which is <code>true</code> for an odd permutation and <code>false</code> for an even permutation. This is implemented with a modified insertion sort algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/bitindex.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.dot-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#CliffordNumbers.dot-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(x::CliffordNumber{Q}, y::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Calculates the dot product of <code>x</code> and <code>y</code>.</p><p>For basis blades <code>A</code> of grade <code>m</code> and <code>B</code> of grade <code>n</code>, the dot product is equal to the left contraction when <code>m &gt;= n</code> and is equal to the right contraction when <code>n &gt;= m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L209-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.dual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q" href="#CliffordNumbers.dual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q"><code>CliffordNumbers.dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual(x::CliffordNumber) -&gt; CliffordNumber</code></pre><p>Calculates the dual of <code>x</code>, which is equal to the left contraction of <code>x</code> with the inverse of the pseudoscalar. However, </p><p>Note that the dual has some properties that depend on the dimension and quadratic form:</p><ul><li>The inverse of the unit pseudoscalar depends on the dimension of the space. Therefore, the</li></ul><p>periodicity of </p><ul><li>If the metric is degenerate, the dual is not unique.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L263-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.elementwise_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}}} where Q" href="#CliffordNumbers.elementwise_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}}} where Q"><code>CliffordNumbers.elementwise_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordAlgebra.elementwise_product(
    x::CliffordNumber{Q},
    y::CliffordNumber{Q},
    a::BitIndex{Q},
    b::BitIndex{Q}
)</code></pre><p>Calculates the geometric product between the element of <code>x</code> indexed by <code>a</code> and the element of <code>y</code> indexed by <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.evil_number-Tuple{Integer}" href="#CliffordNumbers.evil_number-Tuple{Integer}"><code>CliffordNumbers.evil_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.evil_number(n::Integer)</code></pre><p>Returns the nth evil number, with the first evil number (<code>n == 1</code>) defined to be 0.</p><p>Evil numbers are numbers which have an even Hamming weight (sum of its binary digits).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/hamming.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.exppi-Tuple{CliffordNumber}" href="#CliffordNumbers.exppi-Tuple{CliffordNumber}"><code>CliffordNumbers.exppi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exppi(x::CliffordNumber)</code></pre><p>Returns the natural exponential of <code>π * x</code> with greater accuracy than <code>exp(π * x)</code> in the case where <code>x^2</code> is a negative scalar.</p><p>See also: <a href="#Base.exp-Tuple{CliffordNumber}"><code>exp</code></a>, <a href="#CliffordNumbers.exptau-Tuple{CliffordNumber}"><code>exptau</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L358-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.exptau-Tuple{CliffordNumber}" href="#CliffordNumbers.exptau-Tuple{CliffordNumber}"><code>CliffordNumbers.exptau</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exptau(x::CliffordNumber)</code></pre><p>Returns the natural exponential of <code>2π * x</code> with greater accuracy than <code>exp(2π * x)</code> in the case where <code>x^2</code> is a negative scalar.</p><p>See also: <a href="#Base.exp-Tuple{CliffordNumber}"><code>exp</code></a>, <a href="#CliffordNumbers.exppi-Tuple{CliffordNumber}"><code>exppi</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L381-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.grade_involution-Tuple{CliffordNumber}" href="#CliffordNumbers.grade_involution-Tuple{CliffordNumber}"><code>CliffordNumbers.grade_involution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grade_involution(x::CliffordNumber{Q,T}) -&gt; CliffordNumber{Q,T}</code></pre><p>Calculates the grade involution of Clifford number <code>x</code>. This effectively multiplies all of the basis vectors of the space by -1, which makes elements of odd grade flip sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.hamming_number-Tuple{Integer, Integer}" href="#CliffordNumbers.hamming_number-Tuple{Integer, Integer}"><code>CliffordNumbers.hamming_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.hamming_number(w::Integer, n::Integer)</code></pre><p>Gets the <code>n</code>th number with Hamming weight <code>w</code>. The first number with this Hamming weight (<code>n = 1</code>) is <code>2^w - 1</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; CliffordNumbers.hamming_number(3, 2)
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/hamming.jl#L36-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.hestenes_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#CliffordNumbers.hestenes_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.hestenes_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hestenes_product(x::CliffordNumber{Q}, y::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Returns the Hestenes product: this is equal to the dot product given by <code>dot(x, y)</code> but is equal to to zero when either <code>x</code> or <code>y</code> is a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.isevil-Tuple{Integer}" href="#CliffordNumbers.isevil-Tuple{Integer}"><code>CliffordNumbers.isevil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.isevil(i::Integer) -&gt; Bool</code></pre><p>Determines whether a number is evil, meaning that its Hamming weight (sum of its binary digits) is even.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/hamming.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.isodious-Tuple{Integer}" href="#CliffordNumbers.isodious-Tuple{Integer}"><code>CliffordNumbers.isodious</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.isodious(i::Integer) -&gt; Bool</code></pre><p>Determines whether a number is odious, meaning that its Hamming weight (sum of its binary digits) is odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/hamming.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.ispseudoscalar-Tuple{CliffordNumber}" href="#CliffordNumbers.ispseudoscalar-Tuple{CliffordNumber}"><code>CliffordNumbers.ispseudoscalar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispseudoscalar(m::CliffordNumber)</code></pre><p>Determines whether the Clifford number <code>m</code> is a pseudoscalar, meaning that it has no components with grades below the one equal to the dimension of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/numbers.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.isscalar-Tuple{CliffordNumber}" href="#CliffordNumbers.isscalar-Tuple{CliffordNumber}"><code>CliffordNumbers.isscalar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isscalar(m::CliffordNumber)</code></pre><p>Determines whether the Clifford number <code>m</code> is a scalar, meaning that it has no components with grades above zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/numbers.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.left_contraction-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#CliffordNumbers.left_contraction-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.left_contraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">left_contraction(x::CliffordNumber{Q}, y::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Calculates the left contraction of <code>x</code> and <code>y</code>.</p><p>For basis blades <code>A</code> of grade <code>m</code> and <code>B</code> of grade <code>n</code>, the left contraction is zero if <code>n &lt; m</code>, otherwise it is <code>grade_select(A*B, n-m)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L169-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.normalize-Tuple{CliffordNumber}" href="#CliffordNumbers.normalize-Tuple{CliffordNumber}"><code>CliffordNumbers.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize(x::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Normalizes <code>x</code> so that its magnitude (as calculated by <code>abs2(x)</code>) is 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.odious_number-Tuple{Integer}" href="#CliffordNumbers.odious_number-Tuple{Integer}"><code>CliffordNumbers.odious_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.odious_number(n::Integer)</code></pre><p>Returns the nth odious number, with the first odious number (<code>n == 1</code>) defined to be 1.</p><p>Odious numbers are numbers which have an odd Hamming weight (sum of its binary digits).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/hamming.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.right_contraction-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#CliffordNumbers.right_contraction-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.right_contraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">right_contraction(x::CliffordNumber{Q}, y::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Calculates the right contraction of <code>x</code> and <code>y</code>.</p><p>For basis blades <code>A</code> of grade <code>m</code> and <code>B</code> of grade <code>n</code>, the right contraction is zero if <code>m &lt; n</code>, otherwise it is <code>grade_select(A*B, m-n)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L189-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.sandwich-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#CliffordNumbers.sandwich-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.sandwich</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sandwich(x::CliffordNumber{Q}, y::CliffordNumber{Q})</code></pre><p>Calculates the sandwich product of <code>x</code> with <code>y</code>: <code>~y * x * y</code>, but with corrections for numerical stability. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L302-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.scalar_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#CliffordNumbers.scalar_product-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.scalar_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scalar_product(x::CliffordNumber{Q,T1}, y::CliffordNumber{Q,T2}) -&gt; promote_type(T1,T2)</code></pre><p>Calculates the scalar product of two Clifford numbers with quadratic form <code>Q</code>. The result is a <code>Real</code> or <code>Complex</code> number. This can be converted back to a <code>CliffordNumber</code>.</p><p>This is equal to <code>grade_select(x*y, 0)</code> but is significantly more efficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L135-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.select_grade-Tuple{CliffordNumber, Integer}" href="#CliffordNumbers.select_grade-Tuple{CliffordNumber, Integer}"><code>CliffordNumbers.select_grade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_grade(x::CliffordNumber, g::Integer)</code></pre><p>Returns a multivector similar to <code>x</code> where all elements not of grade <code>g</code> are equal to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.sign_of_mult-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{BitIndex{QuadraticForm{P, Q, R}}, BitIndex{QuadraticForm{P, Q, R}}}} where {P, Q, R}" href="#CliffordNumbers.sign_of_mult-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{BitIndex{QuadraticForm{P, Q, R}}, BitIndex{QuadraticForm{P, Q, R}}}} where {P, Q, R}"><code>CliffordNumbers.sign_of_mult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.sign_of_mult(a::T, b::T) where T&lt;:BitIndex{QuadraticForm{P,Q,R}} -&gt; Int8</code></pre><p>Returns an <code>Int8</code> that carries the sign associated with the multiplication of two basis blades of Clifford/geometric algebras of the same quadratic form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/bitindex.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.signbit_of_mult-Tuple{Unsigned, Unsigned}" href="#CliffordNumbers.signbit_of_mult-Tuple{Unsigned, Unsigned}"><code>CliffordNumbers.signbit_of_mult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.signbit_of_mult(a::Integer, [b::Integer]) -&gt; Bool
CliffordNumbers.signbit_of_mult(a::BitIndex, [b::BitIndex]) -&gt; Bool</code></pre><p>Calculates the sign bit associated with multiplying basis elements indexed with bit indices supplied as either integers or <code>BitIndex</code> instances. The sign bit flips when the order of <code>a</code> and <code>b</code> are reversed, unless <code>a === b</code>. </p><p>As with <code>Base.signbit()</code>, <code>true</code> represents a negative sign and <code>false</code> a positive sign. However, in degenerate metrics (such as those of projective geometric algebras) the sign bit may be irrelevant as the multiplication of those basis blades would result in zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/bitindex.jl#L123-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.signmask" href="#CliffordNumbers.signmask"><code>CliffordNumbers.signmask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.signmask(T::Type{&lt;:Integer}, signbit::Bool = true) -&gt; T1</code></pre><p>Generates a signmask, or a string of bits where the only 1 bit is the sign bit. If <code>signbit</code> is set to false, this returns a string of bits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/bitindex.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.subscript_string-Tuple{Number}" href="#CliffordNumbers.subscript_string-Tuple{Number}"><code>CliffordNumbers.subscript_string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordNumbers.subscript_string(x::Number) -&gt; String</code></pre><p>Produces a string representation of a number in subscript format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/CliffordNumbers.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.undual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q" href="#CliffordNumbers.undual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q"><code>CliffordNumbers.undual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">undual(x::CliffordNumber) -&gt; CliffordNumber</code></pre><p>Calculates the undual of <code>x</code>, which is equal to the left contraction of <code>x</code> with the pseudoscalar. This function can be used to reverse the behavior of <code>dual()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L278-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.versor_inverse-Tuple{CliffordNumber}" href="#CliffordNumbers.versor_inverse-Tuple{CliffordNumber}"><code>CliffordNumbers.versor_inverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">versor_inverse(x::CliffordNumber)</code></pre><p>Calculates the versor inverse of <code>x</code>, equal to <code>x / scalar_product(x, ~x)</code>, so that <code>x * inv(x) == inv(x) * x == 1</code>.</p><p>The versor inverse is only guaranteed to be an inverse for blades and versors. Not all Clifford numbers have a well-defined inverse, since Clifford numbers have zero divisors (for instance, in the algebra of physical space, 1 + e₁ has a zero divisor).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L289-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordNumbers.wedge-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q" href="#CliffordNumbers.wedge-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q"><code>CliffordNumbers.wedge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wedge(x::CliffordNumber{Q}, y::CliffordNumber{Q}) -&gt; CliffordNumber{Q}</code></pre><p>Calculates the wedge (outer) product of two Clifford numbers <code>x</code> and <code>y</code> with quadratic form <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/4896ff0251a675a4babec9f067f8468d3706275d/src/math.jl#L241-L245">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 15 February 2024 19:35">Thursday 15 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
