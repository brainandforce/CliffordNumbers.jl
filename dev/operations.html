<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Operations · CliffordNumbers.jl</title><meta name="title" content="Operations · CliffordNumbers.jl"/><meta property="og:title" content="Operations · CliffordNumbers.jl"/><meta property="twitter:title" content="Operations · CliffordNumbers.jl"/><meta name="description" content="Documentation for CliffordNumbers.jl."/><meta property="og:description" content="Documentation for CliffordNumbers.jl."/><meta property="twitter:description" content="Documentation for CliffordNumbers.jl."/><meta property="og:url" content="https://brainandforce.github.io/CliffordNumbers.jl/operations.html"/><meta property="twitter:url" content="https://brainandforce.github.io/CliffordNumbers.jl/operations.html"/><link rel="canonical" href="https://brainandforce.github.io/CliffordNumbers.jl/operations.html"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">CliffordNumbers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="numeric.html">Clifford number types</a></li><li><a class="tocitem" href="metrics.html">Metric signatures</a></li><li><a class="tocitem" href="indexing.html">Indexing</a></li><li class="is-active"><a class="tocitem" href="operations.html">Operations</a><ul class="internal"><li><a class="tocitem" href="#Unary-operations"><span>Unary operations</span></a></li><li><a class="tocitem" href="#Binary-operations"><span>Binary operations</span></a></li></ul></li><li><a class="tocitem" href="performance.html">Performance tips</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="api/clifford.html">CliffordNumbers</a></li><li><a class="tocitem" href="api/indexing.html">Indexing</a></li><li><a class="tocitem" href="api/math.html">Math</a></li><li><a class="tocitem" href="api/metrics.html">Metric signatures</a></li><li><a class="tocitem" href="api/internal.html">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="operations.html">Operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="operations.html">Operations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/brainandforce/CliffordNumbers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/main/docs/src/operations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h1><p>Like with other numbers, standard mathematical operations are supported that relate Clifford numbers to elements of their scalar field and to each other.</p><h2 id="Unary-operations"><a class="docs-heading-anchor" href="#Unary-operations">Unary operations</a><a id="Unary-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Unary-operations" title="Permalink"></a></h2><h3 id="Grade-automorphisms"><a class="docs-heading-anchor" href="#Grade-automorphisms">Grade automorphisms</a><a id="Grade-automorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Grade-automorphisms" title="Permalink"></a></h3><p>Grade automorphisms are operations which preserves the grades of each basis blade, but changes their sign depending on the grade. All of these operations are their own inverse.</p><p>All grade automorphisms are applicable to <code>BitIndex</code> objects, and the way they are implemented is through constructors that use <code>TransformedBitIndices</code> objects to alter each grade.</p><h4 id="Reverse"><a class="docs-heading-anchor" href="#Reverse">Reverse</a><a id="Reverse-1"></a><a class="docs-heading-anchor-permalink" href="#Reverse" title="Permalink"></a></h4><p>The <em>reverse</em> is an operation which reverses the order of the wedge product that constructed each basis blade. This is implemented with methods for <code>Base.reverse</code> and <code>Base.:~</code>.</p><div class="admonition is-info"><header class="admonition-header">Syntax changes</header><div class="admonition-body"><p><code>Base.:~</code> for the reverse is deprecated and will be removed. <code>Base.adjoint</code> provides <code>&#39;</code> as a syntax for the reverse, and is the preferred method for performing the reverse.</p></div></div><p>This is the most commonly used automorphism, and in a sense can be thought of as equivalent to complex conjugation. When working with even elements of the algebras of 2D or 3D space, this behaves identically to complex conjugation and quaternion conjugation. However, this is <em>not</em> the case when working in the even subalgebras.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reverse-Tuple{BitIndex}-operations" href="#Base.reverse-Tuple{BitIndex}-operations"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint(i::BitIndex) = reverse(i::BitIndex) = i&#39; -&gt; BitIndex
adjoint(x::AbstractCliffordNumber) = reverse(x::AbstractCliffordNumber) = x&#39; -&gt; typeof(x)</code></pre><p>Performs the reverse operation on the basis blade indexed by <code>b</code> or the Clifford number <code>x</code>. The  sign of the reverse depends on the grade of the basis blade <code>g</code>, and is positive for <code>g % 4 in 0:1</code> and negative for <code>g % 4 in 2:3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cd32daa8d91c69ba0081e7feba3bf0a64fb64d26/src/bitindex.jl#L176">source</a></section></article><h4 id="Grade-involution"><a class="docs-heading-anchor" href="#Grade-involution">Grade involution</a><a id="Grade-involution-1"></a><a class="docs-heading-anchor-permalink" href="#Grade-involution" title="Permalink"></a></h4><p><em>Grade involution</em> changes the sign of all odd grades, an operation equivalent to mirroring every basis vector of the space. This can be acheived with the <code>grade_involution</code> function.</p><p>When interpreting even multivectors as elements of the even subalgebra of a given algebra, the reverse operation of the algebra is equivalent to grade involution in the even subalgebra.</p><p>Grade involution is equivalent to complex conjugation in when dealing with the even subalgebra of 2D space (which is isomorphic to the complex numbers), but this is <em>not</em> true for quaternion conjugation. Instead, use the Clifford conjugate (described below).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CliffordNumbers.grade_involution-Tuple{BitIndex}-operations" href="#CliffordNumbers.grade_involution-Tuple{BitIndex}-operations"><code>CliffordNumbers.grade_involution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grade_involution(i::BitIndex) -&gt; BitIndex
grade_involution(x::AbstractCliffordNumber) -&gt; typeof(x)</code></pre><p>Calculates the grade involution of the basis blade indexed by <code>b</code> or the Clifford number <code>x</code>. This effectively reflects all of the basis vectors of the space along their own mirror operation, which makes elements of odd grade flip sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cd32daa8d91c69ba0081e7feba3bf0a64fb64d26/src/bitindex.jl#L178-L185">source</a></section></article><h4 id="Clifford-conjugation"><a class="docs-heading-anchor" href="#Clifford-conjugation">Clifford conjugation</a><a id="Clifford-conjugation-1"></a><a class="docs-heading-anchor-permalink" href="#Clifford-conjugation" title="Permalink"></a></h4><p>The <em>Clifford conjugate</em> is the combination of the reverse and grade involution. This is implemented as <code>Base.conj(::AbstractCliffordNumber)</code>. This operation arises in the application of a transformation, because the grade involution accounts for the sign change associated with the parity of the isometry, and it is combined with the reverse to perform the final operation.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>conj(::AbstractCliffordNumber)</code> implements the Clifford conjugate, not the reverse!</p></div></div><p>When dealing with the even subalgebras of 2D and 3D VGAs, which are isomorphic to the complex numbers and quaternions, respectively, the Clifford conjugate is equivalent to complex conjugation or quaternion conjugation. Otherwise, this is a less widely used operation than the above two.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj-Tuple{BitIndex}-operations" href="#Base.conj-Tuple{BitIndex}-operations"><code>Base.conj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj(i::BitIndex) -&gt; BitIndex
conj(x::AbstractCliffordNumber) -&gt; typeof(x)</code></pre><p>Calculates the Clifford conjugate of the basis blade indexed by <code>b</code> or the Clifford number <code>x</code>. This is equal to <code>grade_involution(reverse(x))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brainandforce/CliffordNumbers.jl/blob/cd32daa8d91c69ba0081e7feba3bf0a64fb64d26/src/bitindex.jl#L188-L194">source</a></section></article><h4 id="Inverse"><a class="docs-heading-anchor" href="#Inverse">Inverse</a><a id="Inverse-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse" title="Permalink"></a></h4><p>Many elements of a Clifford algebra have an inverse. In general, the inverse of a rotor <code>R</code> is equal to <code>R&#39; / abs2(R)</code>. It is possible to use other methods to find inverses of arbitrary multivectors of certain Clifford algebras, but this has not been implemented yet.</p><p>Inverses <em>cannot</em> exist for multivectors which square to zero. This is trivially true in any  Clifford algebra with a degenerate metric, but it is possible to encounter these kinds of elements in algebras with positive-definite metrics.</p><h2 id="Binary-operations"><a class="docs-heading-anchor" href="#Binary-operations">Binary operations</a><a id="Binary-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-operations" title="Permalink"></a></h2><h3 id="Addition-and-subtraction"><a class="docs-heading-anchor" href="#Addition-and-subtraction">Addition and subtraction</a><a id="Addition-and-subtraction-1"></a><a class="docs-heading-anchor-permalink" href="#Addition-and-subtraction" title="Permalink"></a></h3><p>Addition and subtraction work as expected for Clifford numbers just as they do for other numbers. The promotion system handles all cases where objects of mixed type are added.</p><h3 id="Products"><a class="docs-heading-anchor" href="#Products">Products</a><a id="Products-1"></a><a class="docs-heading-anchor-permalink" href="#Products" title="Permalink"></a></h3><p>Clifford algebras admit a variety of products. Common ones are implemented with infix operators.</p><h4 id="Geometric-product"><a class="docs-heading-anchor" href="#Geometric-product">Geometric product</a><a id="Geometric-product-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-product" title="Permalink"></a></h4><p>The geometric product, or Clifford product, is the defining product of the Clifford algebra. This is implemented with the usual multiplication operator <code>*</code>, but it is also possible to use parenthetical notation as it is with real numbers.</p><h4 id="Wedge-product"><a class="docs-heading-anchor" href="#Wedge-product">Wedge product</a><a id="Wedge-product-1"></a><a class="docs-heading-anchor-permalink" href="#Wedge-product" title="Permalink"></a></h4><p>The wedge product is the defining product of the exterior algebra. This is available with the <code>wedge()</code> function, or with the <code>∧</code> infix operator.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can define elements of exterior algebras directly by using <code>Metrics.Exterior(D)</code>, whose geometric product is equivalent to the wedge product.</p></div></div><h4 id="Contractions-and-dot-products"><a class="docs-heading-anchor" href="#Contractions-and-dot-products">Contractions and dot products</a><a id="Contractions-and-dot-products-1"></a><a class="docs-heading-anchor-permalink" href="#Contractions-and-dot-products" title="Permalink"></a></h4><p>The contraction operations generalize the dot product of vectors to Clifford numbers. While it is possible to define a symmetric dot product (and one is provided in this package), the generalization of the dot product to Clifford numbers is naturally asymmetric in cases where the grade of one input blade is not equal to that of the other.</p><p>For Clifford numbers <code>x</code> and <code>y</code>, the <em>left contraction</em> <code>x ⨼ y</code> describes the result of projecting <code>x</code> onto the space spanned by <code>y</code>. If <code>x</code> and <code>y</code> are homogeneous in grade, this product is equal to the geometric product if <code>grade(y) ≥ grade(x)</code>, and zero otherwise. For general multivectors, the left contraction can be calculated by applying this rule to the products of their basis blades.</p><p>The analogous right contraction is only nonzero if <code>grade(x) ≥ grade(y)</code>, and it can be calculated with <code>⨽</code>.</p><p>The <em>dot product</em> is a symmetric variation of the left and right contractions, and provides a looser constraint on the basis blades: <code>grade(CliffordNumbers.dot(x,y))</code> must equal <code>abs(grade(x) - grade(y))</code>. The  <em>Hestenes dot product</em> is equivalent to the dot product above, but is zero if either <code>x</code> or <code>y</code> is a scalar.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, the dot product is implemented with the unexported function <code>CliffordNumbers.dot</code>. This package does not depend on LinearAlgebra, so there would be a name conflict if this method were exported and both this package and LinearAlgebra were loaded.</p></div></div><p>Contractions are generally favored over the dot products due to their nicer implementations and properties, which have fewer exceptions. It is generally recommended that the Hestenes dot product  be avoided, though it is included in this library for the sake of completeness as <code>CliffordNumber.hestenes_dot</code>, which is also not exported.</p><h4 id="Commutator-and-anticommutator-products"><a class="docs-heading-anchor" href="#Commutator-and-anticommutator-products">Commutator and anticommutator products</a><a id="Commutator-and-anticommutator-products-1"></a><a class="docs-heading-anchor-permalink" href="#Commutator-and-anticommutator-products" title="Permalink"></a></h4><p>The <em>commutator product</em> (or <em>antisymmetric product</em>) of Clifford numbers <code>x</code> and <code>y</code>, denoted <code>x × y</code>, is equal to <code>1//2 * (x*y - y*x)</code>. This product is nonzero if the geometric product of <code>x</code>  and <code>y</code> does not commute, and the value represents the degree to which they fail to commute.</p><p>The commutator product is the building block of Lie algebras; in particular, the commutator products of bivectors, which are also bivectors. With the bivectors of 3D space, the Lie algebra is equivalent to that generated by the cross product, hence the <code>×</code> notation.</p><p>The analogous <em>anticommutator product</em> (or <em>symmetric product</em>) is <code>1//2 * (x*y + y*x)</code>. This uses the <code>⨰</code> operator, which is not an operator generally used for this purpose, but was selected as it looks similar to the commutator product, with the dot indicating the similarity with the dot product, which is also symmetric.</p><h4 id="Defining-new-products:-Multiplication-internals"><a class="docs-heading-anchor" href="#Defining-new-products:-Multiplication-internals">Defining new products: Multiplication internals</a><a id="Defining-new-products:-Multiplication-internals-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-new-products:-Multiplication-internals" title="Permalink"></a></h4><p>Products are implemented with the fast multiplication kernel <code>CliffordNumbers.mul</code>, which accepts two Clifford numbers with the same scalar type and a <code>CliffordNumbers.GradeFilter</code> object. This <code>GradeFilter</code> object defines a method that takes two or more <code>BitIndex</code> objects and returns <code>false</code> if their product is constrained to be zero.</p><p><code>CliffordNumbers.mul</code> requires that the coefficient types of the numbers being multiplied are the same. Methods which leverage <code>CliffordNumbers.mul</code> should promote the coefficient types of the arguments to a common type using <code>scalar_promote</code> before passing them to the kernel. Any further promotion needed to return the final result is handled by the kernel.</p><p>In general, it is also strongly recommended to promote the types of the arguments to <code>CliffordNumbers.Z2CliffordNumber</code> or <code>CliffordNumber</code> for higher performance. Currently, the implementation of <code>CliffordNumbers.mul</code> is asymmetric, and does not consider which input is longer. Even in the preferred order, we find that <code>KVector</code> incurs a significant performance penalty.</p><h3 id="Exponentiation"><a class="docs-heading-anchor" href="#Exponentiation">Exponentiation</a><a id="Exponentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Exponentiation" title="Permalink"></a></h3><p>Exponentiation can be done using either a Clifford number as a base and an integer exponent, corresponding to iterations of the geometric product, or a Clifford number may be the exponent associated with a scalar.</p><h4 id="Integer-powers-of-Clifford-numbers"><a class="docs-heading-anchor" href="#Integer-powers-of-Clifford-numbers">Integer powers of Clifford numbers</a><a id="Integer-powers-of-Clifford-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-powers-of-Clifford-numbers" title="Permalink"></a></h4><p>As with all other <code>Number</code> instances, this can be done with the <code>^</code> infix operator:</p><pre><code class="nohighlight hljs">julia&gt; k = KVector{1,VGA(3)}(4,2,0)
3-element KVector{1, VGA(3), Int64}:
4e₁ + 2e₂

julia&gt; k^2
1-element KVector{0, VGA(3), Int64}:
20</code></pre><p>However, it may be worth noting that the types may seem to vary based on what Clifford number is being exponentiated. The bivector <code>l</code> squares to an <code>EvenCliffordNumber</code> rather than a <code>KVector{0}</code>:</p><pre><code class="nohighlight hljs">julia&gt; l = KVector{2,VGA(3)}(0, 6, 9)
3-element KVector{2, VGA(3), Int64}:
6e₁e₃ + 9e₂e₃

julia&gt; l^2
4-element EvenCliffordNumber{VGA(3), Int64}:
-117</code></pre><p>This is to be expected: only <span>$k$</span>-blades (<span>$k$</span>-vectors that are the wedge product of <span>$k$</span> 1-vectors) can be guaranteed to square to a scalar. In dimensions less than 4, all <span>$k$</span>-vectors are <span>$k$</span>-blades, but this cannot be assumed in general: the classic example is <span>$e_1 e_2 + e_3 e_4$</span> in 4D VGA, whose square contains a 4-vector term. However, in all dimensions, 0-vectors (scalars) and 1-vectors are guaranteed to be blades, and therefore square to scalars. This is also true of  pseudoscalars and pseudovectors (<span>$n$</span>-blades and <span>$(n-1)$</span>-blades in an <span>$n$</span>-dimensional algebra), but these cases are not recognized yet.</p><p>Furthermore, the types will differ if we exponentiate using a variable rather than a literal  integer:</p><pre><code class="nohighlight hljs">julia&gt; z = 2
2

julia&gt; k^z
8-element CliffordNumber{VGA(3), Float64}:
20.0

julia&gt; l^z
4-element EvenCliffordNumber{VGA(3), Float64}:
-117.0</code></pre><p>Although the results compare as equal with <code>==</code>, they do not with <code>===</code>. The reason for this is type stability, and the mechanisms Julia provides to reduce unnecessary type conversion when enough information is known at compile time.</p><p>Exponentiation is an inherently problematic operation with regards to type stability. This is simply illustrated when raising integers to integer powers: if the exponent is a positive integer, or zero, the result should be an integer, but if the exponent is negative, the result cannot be expressed as an integer unless the number being exponentiated is a unit.</p><p>It may seem like we have to promote every Clifford number that isn&#39;t a <code>KVector{0}</code> to either <code>EvenCliffordNumber</code> or <code>CliffordNumber</code>, but Julia gives us a way to work around this. When any exponentation occurs with a literal number, Julia replaces the expression with <code>Base.literal_pow</code>, and the exponentiation can be converted to a series of multiplications. This package provides these definitions so that all Clifford numbers can be efficiently exponentiated. In particular, we deal with the cases of <code>KVector{0}</code> and <code>KVector{1}</code> explicitly, so that all of their even powers result in a <code>KVector{0}</code>, and the odd powers of a <code>KVector{1}</code> are also a <code>KVector{1}</code>. In the future, we will extend these optimizations to pseudoscalars and pseudovectors.</p><h4 id="Natural-exponentiation"><a class="docs-heading-anchor" href="#Natural-exponentiation">Natural exponentiation</a><a id="Natural-exponentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Natural-exponentiation" title="Permalink"></a></h4><p>It is also possible to raise a real number to a Clifford number power with the <code>exp</code> function, or by raising the irrational constant <code>ℯ</code> to an exponent with <code>^</code>.</p><pre><code class="nohighlight hljs">julia&gt; exp(KVector{2,VGA(3)}(pi/2, 0, 0))
4-element EvenCliffordNumber{VGA(3), Float64}:
6.123233995736766e-17 + 1.0e₁e₂

julia&gt; e^KVector{2,VGA(3)}(pi/2, 0, 0)
4-element EvenCliffordNumber{VGA(3), Float64}:
6.123233995736766e-17 + 1.0e₁e₂</code></pre><p>The most common use case for this operation is to construct rotors from bivectors, as illustrated above.</p><p>Internally, exponentiation is done by a Taylor expansion in the general case, but it is also possible to simplify the exponetiation of <code>KVector</code> instances by identifying the sign of the square of the input. </p><p>Julia provides the <code>sinpi</code>, <code>cospi</code>, and related functions that allow for the calculation of  <code>sin(pi*x)</code> or <code>cos(pi * x)</code>, respectively, with greater accuracy, especially for large <code>x</code>. Although there is no <code>exppi</code> function provided by Julia Base, this packages provides one for use with Clifford numbers, and the accuracy of exponentiation can be expected to be better for  negative-squaring blades.</p><pre><code class="nohighlight hljs">julia&gt; exppi(KVector{2,VGA(3)}(1/2, 0, 0))
4-element EvenCliffordNumber{VGA(3), Float64}:
1.0e₁e₂

julia&gt; exptau(KVector{2,VGA(3)}(1/4, 0, 0))
4-element EvenCliffordNumber{VGA(3), Float64}:
1.0e₁e₂</code></pre><p>This package also provides <code>exptau</code>, which calculates <code>exp(2pi * x)</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="indexing.html">« Indexing</a><a class="docs-footer-nextpage" href="performance.html">Performance tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 23 September 2024 20:47">Monday 23 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
