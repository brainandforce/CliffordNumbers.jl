var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/#The-CliffordNumber-data-type","page":"Getting started","title":"The CliffordNumber data type","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"A CliffordNumber{Q,T,L} is a Clifford number associated with a QuadraticForm Q, a backing Real or Complex type T, and a length L. The length parameter is redundant, and in many cases, it may be omitted without consequence.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"!!! warning Although the length may be omitted in many cases, it's important to remember that a CliffordNumber{Q,T} is not a concrete type. This is important when creating an Array or other container of CliffordNumber elements.","category":"page"},{"location":"getting_started/#Internals","page":"Getting started","title":"Internals","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"A CliffordNumber{Q,T,L} is backed by an NTuple{L,T} where T<:Union{Real,Complex}. The coefficients, however, are not indexed in grade order as is done canonically in most resources.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"!!! danger Read that again: CliffordNumber indexing is not done in grade order.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Instead, the coefficients are arranged in a binary counted fashion, which allows for better SIMD optimization.","category":"page"},{"location":"getting_started/#Constructing-a-Clifford-number","page":"Getting started","title":"Constructing a Clifford number","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The inner constructor for CliffordNumber is CliffordNumber{Cl,T,L}(x), where x is any type that can be converted to an NTuple{L,T}. However, in many cases, the type parameters are redundant, particularly L. For this reason, more constructors exist.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In general, one can use a Vararg constructor to directly input the values.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> CliffordNumber{APS}(1, 2, 3, 4, 5, 6, 7, 8)\nCliffordNumber{APS,Int}(1, 2, 3, 4, 5, 6, 7, 8)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Clifford numbers may also be constructed from real numbers, generating a scalar-valued CliffordNumber:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> CliffordNumber{APS}(1)\nCliffordNumber{APS,Int}(1, 0, 0, 0, 0, 0, 0, 0)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When constructing a CliffordNumber from complex numbers, the type parameters become more important. By default, it is assumed that the element type of a CliffordNumber is a Real. If a complex CliffordNumber is desired, this must be stated explicitly.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> CliffordNumber{APS}(1 + im)\nCliffordNumber{APS,Int}(1, 0, 0, 0, 0, 0, 0, 1)\n\njulia> CliffordNumber{APS,Complex}(1 + im)\nCliffordNumber{APS,Complex{Int}}(1 + im, 0, 0, 0, 0, 0, 0, 0)","category":"page"},{"location":"getting_started/#Quadratic-forms","page":"Getting started","title":"Quadratic forms","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Before getting started with Clifford numbers, it's important to understand how the dimensionality of the space is stored. Unlike with other data types such as StaticArrays.jl's SVector, the total number of dimensions in the space is not all the information that needs to be stored. Each basis vector of the space may square to a positive number, negative number, or zero, defining the quadratic form associated with the Clifford algebra. This information needs to be tracked as a type parameter for CliffordNumber.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To handle this, the QuadraticForm{P,Q,R} type is used to store information about the quadratic form. In this type, P represents","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"!!! note By convention, the QuadraticForm type is not instantiated when used as a type parameter for CliffordNumber instances.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"CliffordNumbers.jl provides the following aliases for common algebras:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"| Algebra    | Alias                  | Note                                           | | VGA{D}   | QuadraticForm{D,0,0} | Vanilla/vector geometric algebra               | | PGA{D}   | QuadraticForm{D,0,1} | Projective geometric algebra                   | | APS      | QuadraticForm{3,0,0} | Algebra of physical space                      | | STA      | QuadraticForm{1,3,0} | Spacetime algebra. By default, uses a -+++     | |            |                        | convention to distinguish it from a conformal  | |            |                        | geometric algebra.                             |","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Currently, an alias for conformal geometric algebras (CGA{D}) does not exist, as it requires some type parameter trickery that hasn't been figured out yet.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CliffordNumbers","category":"page"},{"location":"#CliffordNumbers","page":"Home","title":"CliffordNumbers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CliffordNumbers.jl is a package that provides fully static multivectors (Clifford numbers) in arbitrary dimensions and metrics. While in many cases, sparse representations of multivectors are more efficient, for spaces of low dimension, dense static representations may provide a performance and convenience advantage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CliffordNumbers]","category":"page"},{"location":"#CliffordNumbers.BaseNumber","page":"Home","title":"CliffordNumbers.BaseNumber","text":"CliffordNumbers.BaseNumber\n\nUnion of subtypes of Number provided in the Julia Base module: Real and Complex. This encompasses all types that may be used to construct a CliffordNumber.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.APS","page":"Home","title":"CliffordNumbers.APS","text":"APS\n\nThe algebra of physical space, Cl(3,0,0). An alias for QuadraticForm{3,0,0}.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.AbstractBitIndices","page":"Home","title":"CliffordNumbers.AbstractBitIndices","text":"AbstractBitIndices{Q,C<:AbstractCliffordNumber{Q}} <: AbstractVector{BitIndex{Q}}\n\nSupertype for vectors containing all valid BitIndex{Q} objects for the basis elements represented by C.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.AbstractCliffordNumber","page":"Home","title":"CliffordNumbers.AbstractCliffordNumber","text":"AbstractCliffordNumber{Q,T} <: Number\n\nAn element of a Clifford algebra, often referred to as a multivector, with quadratic form Q and element type T.\n\nInterface\n\nRequired implementation\n\nAll subtypes C of AbstractCliffordNumber{Q} must implement the following functions:\n\nBase.length(x::C) should return the number of nonzero basis elements represented by x.\nCliffordNumbers.similar_type(::Type{C}, ::Type{T}, ::Type{Q}) where {C,T,Q} should construct a\n\nnew type similar to C which subtypes AbstractCliffordNumber{Q,T} that may serve as a constructor.\n\nBase.getindex(x::C, b::BitIndex{Q}) should allow one to recover the coefficients associated\n\nwith each basis blade represented by C.\n\nRequired implementation for static types\n\nBase.length(::Type{C}) should be defined, with Base.length(x::C) = length(typeof(x)).\nBase.Tuple(x::C) should return the tuple used to construct x. The fallback is\n\ngetfield(x, :data)::Tuple, so any type declared with a NTuple field named data should have this defined automatically.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.BitIndex","page":"Home","title":"CliffordNumbers.BitIndex","text":"BitIndex{Q<:QuadraticForm}\n\nA representation of an index corresponding to a basis blade of the geometric algebra with quadratic form Q.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.BitIndex-Union{Tuple{Vararg{Integer}}, Tuple{Q}} where Q","page":"Home","title":"CliffordNumbers.BitIndex","text":"BitIndex{Q}(x::Integer...)\nBitIndex{Q}(v::AbstractVector{<:Integer})\n\nConstructs a BitIndex{Q} from a list of integers that represent the basis vectors of the space.\n\nThis package uses a lexicographic convention for basis blades: in the algebra of physical space, the basis bivectors are {e₁e₂, e₁e₃, e₂e₃}. The sign of the BitIndex{Q} is negative when the parity of the basis vector permutation is odd.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.BitIndices","page":"Home","title":"CliffordNumbers.BitIndices","text":"BitIndices{Q<:QuadraticForm,C<:AbstractCliffordNumber{Q,<:Any}} <: AbstractVector{BitIndex{Q}}\n\nRepresents a range of valid BitIndex objects for the nonzero components of a given multivector  with quadratic form Q.\n\nFor a generic AbstractCliffordNumber{Q}, this returns BitIndices{CliffordNumber{Q}}, which contains all possible indices for a multivector associated with the quadratic form Q. This may  also be constructed with BitIndices(Q).\n\nFor sparse representations, such as KVector{K,Q}, the object only contains the indices of the nonzero elements of the multivector.\n\nConstruction\n\nBitIndices can be constructed by calling the type constructor with either the multivector or its type.\n\nIndexing\n\nBitIndices always uses one-based indexing like most Julia arrays. Although it is more natural in the dense case to use zero-based indexing, as the basis blades are naturally encoded in the indices for the dense representation of CliffordNumber, one-based indexing is used by the tuples which contain the data associated with this package's implementations of Clifford numbers.\n\nInterfaces for new subtypes of AbstractCliffordNumber\n\nWhen defining the behavior of BitIndices for new subtypes T of AbstractCliffordNumber,  Base.getindex(::BitIndices{Q,T}, i::Integer) should be defined so that all indices of T that are not constrained to be zero are returned.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.CliffordNumber","page":"Home","title":"CliffordNumbers.CliffordNumber","text":"CliffordNumber{Q,T,L} <: AbstractCliffordNumber{Q,T}\n\nA dense multivector (or Clifford number), with quadratic form Q, element type T, and length L (which depends entirely on Q).\n\nThe coefficients are ordered by taking advantage of the natural binary structure of the basis. The grade of an element is given by the Hamming weight of its index. For the algebra of physical space, the order is: 1, e₁, e₂, e₁₂, e₃, e₁₃, e₂₃, e₁₂₃ = i. This order allows for more aggressive SIMD optimization when calculating the geometric product.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.KVector","page":"Home","title":"CliffordNumbers.KVector","text":"KVector{K,Q,T,L} <: AbstractCliffordNumber{Q,T}\n\nA multivector consisting only linear combinations of basis blades of grade K - in other words, a k-vector.\n\nk-vectors have binomial(dimension(Q), K) components.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.QFComplex","page":"Home","title":"CliffordNumbers.QFComplex","text":"CliffordNumbers.QFComplex\n\nThe quadratic form with one dimension squaring to -1, QuadraticForm{0,1,0}. This generates a Clifford algebra isomorphic to the complex numbers.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.QFReal","page":"Home","title":"CliffordNumbers.QFReal","text":"CliffordNumbers.QFComplex\n\nThe quadratic form with zero dimensions, QuadraticForm{0,0,0}, isomorphic to the real numbers.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.QuadraticForm","page":"Home","title":"CliffordNumbers.QuadraticForm","text":"CliffordNumbers.QuadratricForm\n\nRepresents a quadratric with P dimensions which square to +1, Q dimensions which square to -1, and R dimensions which square to 0, in that order.\n\nBy convention, this type is used as a tag, and is never instantiated.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.RepresentedGrades","page":"Home","title":"CliffordNumbers.RepresentedGrades","text":"RepresentedGrades{C<:AbstractCliffordNumber} <: AbstractVector{Bool}\n\nA vector describing the grades explicitly represented by some Clifford number type C.\n\nIndexing of a RepresentedGrades{Q} is zero-based, with indices corresponding to all grades from 0 (scalar) to dimension(Q) (pseudoscalar), with true values indicating nonzero grades, and false indicating that the grade is zero.\n\nImplementation\n\nThe function nonzero_grades(::Type{T}) should be implemented for types T descending from  AbstractCliffordNumber.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.STA","page":"Home","title":"CliffordNumbers.STA","text":"STA\n\nSpacetime algebra with a mostly negative signature (particle physicist's convention), Cl(1,3,0). An alias for QuadraticForm{1,3,0}.\n\nThe negative signature is used by default to distinguish this algebra from conformal geometric algebras, which use a mostly positive signature by convention.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.TransformedBitIndices","page":"Home","title":"CliffordNumbers.TransformedBitIndices","text":"TransformedBitIndices{Q,C,F} <: AbstractBitIndices{Q,C}\n\nLazy representation of BitIndices{Q,C} with some function of type f applied to each element. These objects can be used to perform common operations which act on basis blades or grades, such as the reverse or grade involution.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordNumbers.Z2CliffordNumber","page":"Home","title":"CliffordNumbers.Z2CliffordNumber","text":"CliffordNumbers.Z2CliffordNumber{P,Q,T,L}\n\nA Clifford number whose only nonzero grades are even or odd. Clifford numbers of this form naturally arise as versors, the geometric product of 1-vectors.\n\nThe type parameter P is constrained to be a Bool: true for odd grade Clifford numbers, and false for even grade Clifford numbers, corresponding to the Boolean result of each grade modulo 2.\n\nType aliases\n\nThis type is not exported, and usually you will want to refer to the following aliases:\n\nconst EvenCliffordNumber{Q,T,L} = Z2CliffordNumber{false,Q,T,L}\nconst OddCliffordNumber{Q,T,L} = Z2CliffordNumber{true,Q,T,L}\n\n\n\n\n\n","category":"type"},{"location":"#Base.:*-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"Home","title":"Base.:*","text":"*(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n(x::AbstractCliffordNumber{Q})(y::AbstractCliffordNumber{Q})\n\nCalculates the geometric product of x and y, returning the smallest type which is able to represent all nonzero basis blades of the result.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{T, T}} where T<:BitIndex","page":"Home","title":"Base.:*","text":"*(a::BitIndex{Q}, b::BitIndex{Q}) -> BitIndex{Q}\n\nReturns the BitIndex corresponding to the basis blade resulting from the geometric product of the basis blades indexed by a and b.\n\n\n\n\n\n","category":"method"},{"location":"#Base.abs-Tuple{AbstractCliffordNumber}","page":"Home","title":"Base.abs","text":"abs2(x::CliffordNumber{Q,T}) -> Union{Real,Complex}\n\nCalculates the norm of x, equal to sqrt(scalar_product(x, ~x)).\n\n\n\n\n\n","category":"method"},{"location":"#Base.abs2-Tuple{AbstractCliffordNumber}","page":"Home","title":"Base.abs2","text":"abs2(x::AbstractCliffordNumber{Q,T}) -> T\n\nCalculates the squared norm of x, equal to scalar_product(x, ~x).\n\n\n\n\n\n","category":"method"},{"location":"#Base.conj-Tuple{BitIndex}","page":"Home","title":"Base.conj","text":"conj(b::BitIndex) -> BitIndex\nconj(x::AbstractCliffordNumber) -> typeof(x)\n\nCalculates the Clifford conjugate of the basis blade indexed by b or the Clifford number x. This is equal to grade_involution(reverse(x)).\n\n\n\n\n\n","category":"method"},{"location":"#Base.exp-Tuple{AbstractCliffordNumber}","page":"Home","title":"Base.exp","text":"exp(x::AbstractCliffordNumber{Q})\n\nReturns the natural exponential of a Clifford number.\n\nFor special cases where m squares to a scalar, the following shortcuts can be used to calculate exp(x):\n\nWhen x^2 < 0: exp(x) === cos(abs(x)) + x * sin(abs(x)) / abs(x)\nWhen x^2 > 0: exp(x) === cosh(abs(x)) + x * sinh(abs(x)) / abs(x)\nWhen x^2 === 0: exp(x) == 1 + x\n\nSee also: exppi, exptau.\n\n\n\n\n\n","category":"method"},{"location":"#Base.real-Union{Tuple{AbstractCliffordNumber{Q, <:Real}}, Tuple{Q}} where Q","page":"Home","title":"Base.real","text":"real(x::CliffordNumber{Q,T<:Real}) = T\n\nReturn the real (scalar) portion of a real Clifford number. \n\n\n\n\n\n","category":"method"},{"location":"#Base.reverse-Tuple{BitIndex}","page":"Home","title":"Base.reverse","text":"reverse(b::BitIndex) -> BitIndex\nreverse(x::AbstractCliffordNumber) -> typeof(x)\n\nPerforms the reverse operation on the basis blade indexed by b or the Clifford number x. The  sign of the reverse depends on the grade, and is positive for g % 4 in 0:1 and negative for g % 4 in 2:3.\n\n\n\n\n\n","category":"method"},{"location":"#Base.sign-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{Type{QuadraticForm{P, Q, R}}, Integer}} where {P, Q, R}","page":"Home","title":"Base.sign","text":"sign(::Type{QuadraticForm{P,Q,R}}, i::Integer) -> Int8\n\nGets the sign associated with dimension i of a quadratric form.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.CGA-Tuple{Any}","page":"Home","title":"CliffordNumbers.CGA","text":"CGA(D) -> Type{QuadraticForm{D+1,1,0}}\n\nCreates the type of a quadratic form associated with a conformal geometric algebra (CGA) of dimension D.\n\nFor reasons of type stability, avoid calling this function without constant arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.PGA-Tuple{Any}","page":"Home","title":"CliffordNumbers.PGA","text":"PGA(D) -> Type{QuadraticForm{D,0,1}}\n\nCreates the type of a quadratic form associated with a projective geometric algebra (PGA) of dimension D.\n\nFor reasons of type stability, avoid calling this function without constant arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.VGA-Tuple{Any}","page":"Home","title":"CliffordNumbers.VGA","text":"VGA(D) -> Type{QuadraticForm{D,0,0}}\n\nCreates the type of a quadratic form associated with a vector/vanilla geometric algebra (VGA) of dimension D.\n\nFor reasons of type stability, avoid calling this function without constant arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers._sort_with_parity!-Tuple{AbstractVector{<:Real}}","page":"Home","title":"CliffordNumbers._sort_with_parity!","text":"CliffordNumbers._sort_with_parity!(v::AbstractVector{<:Real}) -> Tuple{typeof(v),Bool}\n\nPerforms a parity-tracking insertion sort of v, which modifies v in place. The function returns a tuple containing v and the parity, which is true for an odd permutation and false for an even permutation. This is implemented with a modified insertion sort algorithm.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.anticommutator-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"Home","title":"CliffordNumbers.anticommutator","text":"anticommutator(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the anticommutator (or symmetric) product, equal to 1//2 * (x*y + y*x), or equivalently, 1//2 * (x*y + reverse(x*y)).\n\nNote that the dot product, in general, is not equal to the anticommutator product, which may be invoked with dot. In some cases, the preferred operators might be the left and right contractions, which use infix operators ⨼ and ⨽ respectively.\n\nType promotion\n\nBecause of the rational 1//2 factor in the product, inputs with scalar types subtyping Integer will be promoted to Rational subtypes.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.check_element_count-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Any, Type{QuadraticForm{X, Y, Z}}, Any}} where {X, Y, Z}","page":"Home","title":"CliffordNumbers.check_element_count","text":"CliffordNumbers.check_element_count(f, Q::Type{<:QuadraticForm}, [L,] data)\n\nEnsures that the number of elements in data is the same as the result of f(Q), where f is a function that generates the expected number of elements for the type. This function is used in the inner constructors of subtypes of AbstractCliffordNumber{Q} to ensure that the input has the correct length.\n\nIf provided, the length type parameter L can be included as an argument, and it will be checked for type (must be an Int) and value (must be equal to f(Q)).\n\nThis function returns nothing, but throws an AssertionError for failed checks.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.commutator-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"Home","title":"CliffordNumbers.commutator","text":"commutator(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n×(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the commutator (or antisymmetric) product, equal to 1//2 * (x*y - y*x), or equivalently, 1//2 * (x*y - reverse(x*y)).\n\nNote that the commutator product, in general, is not equal to the wedge product, which may be invoked with the wedge function or the ∧ operator.\n\nType promotion\n\nBecause of the rational 1//2 factor in the product, inputs with scalar types subtyping Integer will be promoted to Rational subtypes.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.contraction-Union{Tuple{B}, Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, Val{B}}} where {Q, B}","page":"Home","title":"CliffordNumbers.contraction","text":"CliffordNumbers.contraction(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q}, ::Val)\n\nGeneric implementation of left and right contractions as well as dot products. The left contraction is calculated if the final argument is Val(true); the right contraction is calcluated if the final argument is Val(false), and the dot product is calculated for any other Val.\n\nIn general, code should never refer to this method directly; use left_contraction, right_contraction, or dot if needed.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.dot-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"Home","title":"CliffordNumbers.dot","text":"dot(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the dot product of x and y.\n\nFor basis blades A of grade m and B of grade n, the dot product is equal to the left contraction when m >= n and is equal to the right contraction when n >= m.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.dual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q","page":"Home","title":"CliffordNumbers.dual","text":"dual(x::CliffordNumber) -> CliffordNumber\n\nCalculates the dual of x, which is equal to the left contraction of x with the inverse of the pseudoscalar. However, \n\nNote that the dual has some properties that depend on the dimension and quadratic form:\n\nThe inverse of the unit pseudoscalar depends on the dimension of the space. Therefore, the\n\nperiodicity of \n\nIf the metric is degenerate, the dual is not unique.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.elementwise_product-Union{Tuple{C}, Tuple{Q}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}, Bool}} where {Q, C<:(AbstractCliffordNumber{Q})}","page":"Home","title":"CliffordNumbers.elementwise_product","text":"CliffordNumbers.elementwise_product(\n    [::Type{C},]\n    x::AbstractCliffordNumber{Q},\n    y::AbstractCliffordNumber{Q},\n    a::BitIndex{Q},\n    b::BitIndex{Q},\n    [condition = true]\n) where {Q,T<:AbstractCliffordNumber{Q}} -> C\n\nCalculates the geometric product between the element of x indexed by a and the element of y indexed by b. The result is returned as type C, but this can be inferred automatically if not provided.\n\nAn optional boolean condition can be provided, which simplifies the implementation of certain products derived from the geometric product.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.evil_number-Tuple{Integer}","page":"Home","title":"CliffordNumbers.evil_number","text":"CliffordNumbers.evil_number(n::Integer)\n\nReturns the nth evil number, with the first evil number (n == 1) defined to be 0.\n\nEvil numbers are numbers which have an even Hamming weight (sum of its binary digits).\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.exp_taylor","page":"Home","title":"CliffordNumbers.exp_taylor","text":"CliffordNumbers.exp_taylor(x::AbstractCliffordNumber, order = 12)\n\nCalculates the exponential of x using a Taylor expansion up to the specified order. In most cases, 12 is as sufficient number.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordNumbers.exponential_type-Union{Tuple{Type{C}}, Tuple{C}, Tuple{Q}} where {Q, C<:(AbstractCliffordNumber{Q})}","page":"Home","title":"CliffordNumbers.exponential_type","text":"CliffordNumbers.exponential_type(::Type{<:AbstractCliffordNumber})\nCliffordNumbers.exponential_type(x::AbstractCliffordNumber)\n\nReturns the type expected when exponentiating a Clifford number. This is an EvenCliffordNumber if the nonzero grades of the input are even, a CliffordNumber otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.exppi-Tuple{AbstractCliffordNumber}","page":"Home","title":"CliffordNumbers.exppi","text":"exppi(x::AbstractCliffordNumber)\n\nReturns the natural exponential of π * x with greater accuracy than exp(π * x) in the case where x^2 is a negative scalar, especially for large values of abs(x).\n\nSee also: exp, exptau.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.exptau-Tuple{AbstractCliffordNumber}","page":"Home","title":"CliffordNumbers.exptau","text":"exptau(x::AbstractCliffordNumber)\n\nReturns the natural exponential of 2π * x with greater accuracy than exp(2π * x) in the case where x^2 is a negative scalar, especially for large values of abs(x).\n\nSee also: exp, exppi.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.grade-Union{Tuple{Type{<:KVector{K}}}, Tuple{K}} where K","page":"Home","title":"CliffordNumbers.grade","text":"grade(::Type{<:KVector{K}}) = K\ngrade(x::KVector{K}) = k\n\nReturns the grade represented by a KVector{K}, which is K.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.grade_involution-Tuple{BitIndex}","page":"Home","title":"CliffordNumbers.grade_involution","text":"grade_involution(b::BitIndex) -> BitIndex\ngrade_involution(x::AbstractCliffordNumber) -> typeof(x)\n\nCalculates the grade involution of the basis blade indexed by b or the Clifford number x. This effectively reflects all of the basis vectors of the space along their own mirror operation, which makes elements of odd grade flip sign.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.hamming_number-Tuple{Integer, Integer}","page":"Home","title":"CliffordNumbers.hamming_number","text":"CliffordNumbers.hamming_number(w::Integer, n::Integer)\n\nGets the nth number with Hamming weight w. The first number with this Hamming weight (n = 1) is 2^w - 1.\n\nExample\n\njulia> CliffordNumbers.hamming_number(3, 2)\n11\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.has_grades_of-Tuple{Type{<:AbstractCliffordNumber}, Type{<:AbstractCliffordNumber}}","page":"Home","title":"CliffordNumbers.has_grades_of","text":"has_grades_of(S::Type{<:AbstractCliffordNumber}, T::Type{<:AbstractCliffordNumber}) -> Bool\nhas_grades_of(x::AbstractCliffordNumber, y::AbstractCliffordNumber) -> Bool\n\nReturns true if the grades represented in S are also represented in T; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.has_wedge-Union{Tuple{Q}, Tuple{BitIndex{Q}, BitIndex{Q}}} where Q","page":"Home","title":"CliffordNumbers.has_wedge","text":"CliffordNumbers.has_wedge(a::BitIndex{Q}, b::BitIndex{Q}) -> Bool\n\nReturns true if the basis blades indexed by a and b may have a nonzero wedge product.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.hestenes_product-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"Home","title":"CliffordNumbers.hestenes_product","text":"hestenes_product(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nReturns the Hestenes product: this is equal to the dot product given by dot(x, y) but is equal to to zero when either x or y is a scalar.\n\nThis product is generally understood to lack utility; left and right contractions are preferred over this product in almost every case. It is implemented for the sake of completeness.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.isevil-Tuple{Integer}","page":"Home","title":"CliffordNumbers.isevil","text":"CliffordNumbers.isevil(i::Integer) -> Bool\n\nDetermines whether a number is evil, meaning that its Hamming weight (sum of its binary digits) is even.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.isodious-Tuple{Integer}","page":"Home","title":"CliffordNumbers.isodious","text":"CliffordNumbers.isodious(i::Integer) -> Bool\n\nDetermines whether a number is odious, meaning that its Hamming weight (sum of its binary digits) is odd.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.ispseudoscalar-Tuple{AbstractCliffordNumber}","page":"Home","title":"CliffordNumbers.ispseudoscalar","text":"ispseudoscalar(m::AbstractCliffordNumber)\n\nDetermines whether the Clifford number x is a pseudoscalar, meaning that all of its blades with grades below the dimension of the space are zero.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.isscalar-Tuple{AbstractCliffordNumber}","page":"Home","title":"CliffordNumbers.isscalar","text":"isscalar(x::AbstractCliffordNumber)\n\nDetermines whether the Clifford number x is a scalar, meaning that all of its blades of nonzero grade are zero.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.left_contraction-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"Home","title":"CliffordNumbers.left_contraction","text":"left_contraction(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n⨼(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the left contraction of x and y.\n\nFor basis blades A of grade m and B of grade n, the left contraction is zero if n < m, otherwise it is KVector{n-m,Q}(A*B).\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.next_of_hamming_weight-Tuple{Integer}","page":"Home","title":"CliffordNumbers.next_of_hamming_weight","text":"CliffordNumbers.next_of_hamming_weight(n::Integer)\n\nReturns the next integer with the same Hamming weight as n.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.nonzero_grades-Tuple{Number}","page":"Home","title":"CliffordNumbers.nonzero_grades","text":"nonzero_grades(::Type{<:AbstractCliffordNumber})\nnonzero_grades(::AbstractCliffordNumber)\n\nA function returning an indexable object representing all nonzero grades of a Clifford number representation.\n\nThis function is used to define the indexing of RepresentedGrades, and should be defined for any subtypes of AbstractCliffordNumber.\n\nExamples\n\njulia> CliffordNumbers.nonzero_grades(CliffordNumber{APS})\n0:3\n\njulia> CliffordNumbers.nonzero_grades(KVector{2,APS})\n2:2\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.normalize-Tuple{AbstractCliffordNumber}","page":"Home","title":"CliffordNumbers.normalize","text":"normalize(x::AbstractCliffordNumber{Q}) -> AbstractCliffordNumber{Q}\n\nNormalizes x so that its magnitude (as calculated by abs2(x)) is 1.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.number_of_parity-Tuple{Integer, Bool}","page":"Home","title":"CliffordNumbers.number_of_parity","text":"CliffordNumbers.number_of_parity(n::Integer, modulo::Bool)\n\nReturns the nth number whose Hamming weight is even (for modulo = false) or odd (for modulo = true).\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.numeric_type-Tuple{Type}","page":"Home","title":"CliffordNumbers.numeric_type","text":"numeric_type(::Type{<:AbstractCliffordNumber{Q,T}}) = T\nnumeric_type(T::Type{<:Union{Real,Complex}}) = T\nnumeric_type(x) = numeric_type(typeof(x))\n\nReturns the numeric type associated with an AbstractCliffordNumber instance. For subtypes of Real and Complex, or their instances, this simply returns the input type or instance type.\n\nWhy not define eltype?\n\nAbstractCliffordNumber instances behave like numbers, not arrays. If collect() is called on a Clifford number of type T, it should not construct a vector of coefficients; instead it should return an Array{T,0}. Similarly, a broadcasted multiplication should return the same result as normal multiplication, as is the case with complex numbers.\n\nFor subtypes T of Number, eltype(T) === T, and this is true for AbstractCliffordNumber.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.odious_number-Tuple{Integer}","page":"Home","title":"CliffordNumbers.odious_number","text":"CliffordNumbers.odious_number(n::Integer)\n\nReturns the nth odious number, with the first odious number (n == 1) defined to be 1.\n\nOdious numbers are numbers which have an odd Hamming weight (sum of its binary digits).\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.product_kernel-Union{Tuple{T}, Tuple{Q}, Tuple{Type{T}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}, Tuple{Type{T}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, Any}} where {Q, T<:(AbstractCliffordNumber{Q})}","page":"Home","title":"CliffordNumbers.product_kernel","text":"CliffordNumbers.product_kernel(\n    ::Type{T},\n    x::AbstractCliffordNumber{Q},\n    y::AbstractCliffordNumber{Q},\n    f = ((a,b) -> true)\n)\n\nLeverages CliffordNumbers.elementwise_product to calculate a geometric product in a \n\nThe optional function f is a condition used to exclude elementwise products whose associated BitIndex{Q} objects a and b do not meet a specific criterion. This function must always evaluate to a Bool. By default, it evaluates to true every time.\n\nWhy not simply use sum()?\n\nIt appears that sum() is unable to correctly infer the type of the result of an expression like the one given below:\n\nsum(\n    elementwise_product(T, x, y, a, b)\n    for (a,b) in Iterators.filter(f, Iterators.product(BitIndices(x), BitIndices(y)))\n)\n\nTherefore, it is manually implemented in a for loop.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.promote_numeric_type-Tuple{}","page":"Home","title":"CliffordNumbers.promote_numeric_type","text":"promote_numeric_type(x, y)\n\nCalls promote_type() for the result of numeric_type() called on all arguments. For incompletely specified types, the result of numeric_type() is replaced with Bool, which always promotes to any larger numeric type.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.pseudoscalar_index-Union{Tuple{Type{<:AbstractCliffordNumber{Q}}}, Tuple{Q}} where Q","page":"Home","title":"CliffordNumbers.pseudoscalar_index","text":"pseudoscalar_index(x::AbstractCliffordNumber{Q}) -> BitIndex{Q}()\n\nConstructs the BitIndex used to obtain the pseudoscalar (highest grade) portion of x.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.right_contraction-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"Home","title":"CliffordNumbers.right_contraction","text":"right_contraction(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n⨽(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the right contraction of x and y.\n\nFor basis blades A of grade m and B of grade n, the right contraction is zero if m < n, otherwise it is KVector{m-n,Q}(A*B).\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.sandwich-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q","page":"Home","title":"CliffordNumbers.sandwich","text":"sandwich(x::CliffordNumber{Q}, y::CliffordNumber{Q})\n\nCalculates the sandwich product of x with y: ~y * x * y, but with corrections for numerical stability. \n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.scalar_index-Union{Tuple{Type{<:AbstractCliffordNumber{Q}}}, Tuple{Q}} where Q","page":"Home","title":"CliffordNumbers.scalar_index","text":"scalar_index(x::AbstractCliffordNumber{Q}) -> BitIndex{Q}()\n\nConstructs the BitIndex used to obtain the scalar (grade zero) portion of x.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.scalar_product-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"Home","title":"CliffordNumbers.scalar_product","text":"scalar_product(x::CliffordNumber{Q,T1}, y::CliffordNumber{Q,T2}) -> promote_type(T1,T2)\n\nCalculates the scalar product of two Clifford numbers with quadratic form Q. The result is a Real or Complex number. This can be converted back to an AbstractCliffordNumber.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.select_grade-Tuple{CliffordNumber, Integer}","page":"Home","title":"CliffordNumbers.select_grade","text":"select_grade(x::CliffordNumber, g::Integer)\n\nReturns a multivector similar to x where all elements not of grade g are equal to zero.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.sign_of_mult-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{BitIndex{QuadraticForm{P, Q, R}}, BitIndex{QuadraticForm{P, Q, R}}}} where {P, Q, R}","page":"Home","title":"CliffordNumbers.sign_of_mult","text":"CliffordNumbers.sign_of_mult(a::T, b::T) where T<:BitIndex{QuadraticForm{P,Q,R}} -> Int8\n\nReturns an Int8 that carries the sign associated with the multiplication of two basis blades of Clifford/geometric algebras of the same quadratic form.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.signbit_of_mult-Tuple{Unsigned, Unsigned}","page":"Home","title":"CliffordNumbers.signbit_of_mult","text":"CliffordNumbers.signbit_of_mult(a::Integer, [b::Integer]) -> Bool\nCliffordNumbers.signbit_of_mult(a::BitIndex, [b::BitIndex]) -> Bool\n\nCalculates the sign bit associated with multiplying basis elements indexed with bit indices supplied as either integers or BitIndex instances. The sign bit flips when the order of a and b are reversed, unless a === b. \n\nAs with Base.signbit(), true represents a negative sign and false a positive sign. However, in degenerate metrics (such as those of projective geometric algebras) the sign bit may be irrelevant as the multiplication of those basis blades would result in zero.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.signmask","page":"Home","title":"CliffordNumbers.signmask","text":"CliffordNumbers.signmask(T::Type{<:Integer}, signbit::Bool = true) -> T1\n\nGenerates a signmask, or a string of bits where the only 1 bit is the sign bit. If signbit is set to false, this returns a string of bits.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordNumbers.similar_type-Tuple{AbstractCliffordNumber, Type{<:Union{Real, Complex}}, Type{<:QuadraticForm}}","page":"Home","title":"CliffordNumbers.similar_type","text":"CliffordNumbers.similar_type(\n    C::Type{<:AbstractCliffordNumber},\n    [N::Type{<:BaseNumber} = numeric_type(C)],\n    [Q::Type{<:QuadraticForm} = QuadraticForm(C)]\n) -> Type{<:AbstractCliffordNumber{Q,N}}\n\nConstructs a type similar to T but with numeric type N and quadratic form Q.\n\nThis function must be defined with all its arguments for each concrete type subtyping AbstractCliffordNumber.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.subscript_string-Tuple{Number}","page":"Home","title":"CliffordNumbers.subscript_string","text":"CliffordNumbers.subscript_string(x::Number) -> String\n\nProduces a string representation of a number in subscript format.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.to_basis_str-Union{Tuple{BitIndex{Q}}, Tuple{Q}} where Q","page":"Home","title":"CliffordNumbers.to_basis_str","text":"CliffordNumbers.to_basis_str(b::BitIndex; [label], [pseudoscalar])\n\nCreates a string representation of the basis element given by b.\n\nThe label parameter determines the symbol used for every basis element. In general, this defaults to e, but a few special cases use different symbols:\n\nFor the algebra of physical space, σ is used.\nFor the spacetime algebras of either signature, γ is used.\n\nIf pseudoscalar is set, the pseudoscalar may be printed using a different symbol from the rest of the basis elements.\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.undual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q","page":"Home","title":"CliffordNumbers.undual","text":"undual(x::CliffordNumber) -> CliffordNumber\n\nCalculates the undual of x, which is equal to the left contraction of x with the pseudoscalar. This function can be used to reverse the behavior of dual().\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.versor_inverse-Tuple{CliffordNumber}","page":"Home","title":"CliffordNumbers.versor_inverse","text":"versor_inverse(x::CliffordNumber)\n\nCalculates the versor inverse of x, equal to x / scalar_product(x, ~x), so that x * inv(x) == inv(x) * x == 1.\n\nThe versor inverse is only guaranteed to be an inverse for blades and versors. Not all Clifford numbers have a well-defined inverse, since Clifford numbers have zero divisors (for instance, in the algebra of physical space, 1 + e₁ has a zero divisor).\n\n\n\n\n\n","category":"method"},{"location":"#CliffordNumbers.wedge-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"Home","title":"CliffordNumbers.wedge","text":"wedge(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n∧(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the wedge (outer) product of two Clifford numbers x and y with quadratic form Q.\n\nNote that the wedge product, in general, is not equal to the commutator product (or antisymmetric product), which may be invoked with the commutator function or the × operator.\n\n\n\n\n\n","category":"method"}]
}
