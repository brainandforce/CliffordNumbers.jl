var documenterSearchIndex = {"docs":
[{"location":"api.html#API-reference","page":"API","title":"API reference","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [CliffordNumbers]","category":"page"},{"location":"api.html#CliffordNumbers.BaseNumber","page":"API","title":"CliffordNumbers.BaseNumber","text":"CliffordNumbers.BaseNumber\n\nUnion of subtypes of Number provided in the Julia Base module: Real and Complex. This encompasses all types that may be used to construct a CliffordNumber.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.APS","page":"API","title":"CliffordNumbers.APS","text":"APS\n\nThe algebra of physical space, Cl(3,0,0). An alias for QuadraticForm{3,0,0}.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.AbstractBitIndices","page":"API","title":"CliffordNumbers.AbstractBitIndices","text":"AbstractBitIndices{Q,C<:AbstractCliffordNumber{Q}} <: AbstractVector{BitIndex{Q}}\n\nSupertype for vectors containing all valid BitIndex{Q} objects for the basis elements represented by C.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.AbstractCliffordNumber","page":"API","title":"CliffordNumbers.AbstractCliffordNumber","text":"AbstractCliffordNumber{Q,T} <: Number\n\nAn element of a Clifford algebra, often referred to as a multivector, with quadratic form Q and element type T.\n\nInterface\n\nRequired implementation\n\nAll subtypes C of AbstractCliffordNumber{Q} must implement the following functions:\n\nBase.length(x::C) should return the number of nonzero basis elements represented by x.\nCliffordNumbers.similar_type(::Type{C}, ::Type{T}, ::Type{Q}) where {C,T,Q} should construct a\n\nnew type similar to C which subtypes AbstractCliffordNumber{Q,T} that may serve as a constructor.\n\nBase.getindex(x::C, b::BitIndex{Q}) should allow one to recover the coefficients associated\n\nwith each basis blade represented by C.\n\nRequired implementation for static types\n\nBase.length(::Type{C}) should be defined, with Base.length(x::C) = length(typeof(x)).\nBase.Tuple(x::C) should return the tuple used to construct x. The fallback is\n\ngetfield(x, :data)::Tuple, so any type declared with a NTuple field named data should have this defined automatically.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.BitIndex","page":"API","title":"CliffordNumbers.BitIndex","text":"BitIndex{Q<:QuadraticForm}\n\nA representation of an index corresponding to a basis blade of the geometric algebra with quadratic form Q.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.BitIndex-Union{Tuple{Q}, Tuple{Type{Q}, Vararg{Integer}}} where Q<:QuadraticForm","page":"API","title":"CliffordNumbers.BitIndex","text":"BitIndex(Q::Type{<:QuadraticForm}, i::Integer...)\nBitIndex(x, i::Integer...) = BitIndex(QuadraticForm(x), i...)\n\nConstructs a BitIndex{Q} from a list of integers that represent the basis 1-vectors of the space. Q can be determined from the QuadraticForm associated with x, whether it be a type or object.\n\nThis package uses a lexicographic convention for basis blades: in the algebra of physical space, the basis bivectors are {e₁e₂, e₁e₃, e₂e₃}. The sign of the BitIndex{Q} is negative when the parity of the basis vector permutation is odd.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.BitIndices","page":"API","title":"CliffordNumbers.BitIndices","text":"BitIndices{Q<:QuadraticForm,C<:AbstractCliffordNumber{Q,<:Any}} <: AbstractVector{BitIndex{Q}}\n\nRepresents a range of valid BitIndex objects for the nonzero components of a given multivector  with quadratic form Q.\n\nFor a generic AbstractCliffordNumber{Q}, this returns BitIndices{CliffordNumber{Q}}, which contains all possible indices for a multivector associated with the quadratic form Q. This may  also be constructed with BitIndices(Q).\n\nFor sparse representations, such as KVector{K,Q}, the object only contains the indices of the nonzero elements of the multivector.\n\nConstruction\n\nBitIndices can be constructed by calling the type constructor with either the multivector or its type.\n\nIndexing\n\nBitIndices always uses one-based indexing like most Julia arrays. Although it is more natural in the dense case to use zero-based indexing, as the basis blades are naturally encoded in the indices for the dense representation of CliffordNumber, one-based indexing is used by the tuples which contain the data associated with this package's implementations of Clifford numbers.\n\nInterfaces for new subtypes of AbstractCliffordNumber\n\nWhen defining the behavior of BitIndices for new subtypes T of AbstractCliffordNumber,  Base.getindex(::BitIndices{Q,T}, i::Integer) should be defined so that all indices of T that are not constrained to be zero are returned.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.CliffordNumber","page":"API","title":"CliffordNumbers.CliffordNumber","text":"CliffordNumber{Q,T,L} <: AbstractCliffordNumber{Q,T}\n\nA dense multivector (or Clifford number), with quadratic form Q, element type T, and length L (which depends entirely on Q).\n\nThe coefficients are ordered by taking advantage of the natural binary structure of the basis. The grade of an element is given by the Hamming weight of its index. For the algebra of physical space, the order is: 1, e₁, e₂, e₁₂, e₃, e₁₃, e₂₃, e₁₂₃ = i. This order allows for more aggressive SIMD optimization when calculating the geometric product.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.EvenCliffordNumber","page":"API","title":"CliffordNumbers.EvenCliffordNumber","text":"EvenCliffordNumber{P,Q,T,L} (alias for CliffordNumbers.Z2CliffordNumber{false,Q,T,L})\n\nA Clifford number whose only nonzero grades are even. These are the natural choice of representation for rotors and motors (Euclidean isometries preserving orientation, or \"proper\" isometries), as well as their composition with dilations.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.GradeFilter","page":"API","title":"CliffordNumbers.GradeFilter","text":"CliffordNumbers.GradeFilter{S}\n\nA type that can be used to filter certain products of blades in a geometric product multiplication. The type parameter S must be a Symbol. The single instance of GradeFilter{S} is a callable object which implements a function that takes two or more BitIndex{Q} objects a and b and returns false if the product of the blades indexed is zero.\n\nTo implement a grade filter for a product function f, define the following method:     (::GradeFilter{:f})(::BitIndex{Q}, ::BitIndex{Q})     # Or if the definition allows for more arguments     (::GradeFilter{:f})(::BitIndex{Q}...) where Q\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.KVector","page":"API","title":"CliffordNumbers.KVector","text":"KVector{K,Q,T,L} <: AbstractCliffordNumber{Q,T}\n\nA multivector consisting only linear combinations of basis blades of grade K - in other words, a k-vector.\n\nk-vectors have binomial(dimension(Q), K) components.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.OddCliffordNumber","page":"API","title":"CliffordNumbers.OddCliffordNumber","text":"OddCliffordNumber{P,Q,T,L} (alias for CliffordNumbers.Z2CliffordNumber{true,Q,T,L})\n\nA Clifford number whose only nonzero grades are odd. These are the natural choice of representation for reflections, as well as their compositions with rotors and motors (Euclidean isometries  preserving orientation, or \"proper\" isometries), as well as their composition with dilations.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.QFComplex","page":"API","title":"CliffordNumbers.QFComplex","text":"CliffordNumbers.QFComplex\n\nThe quadratic form with one dimension squaring to -1, QuadraticForm{0,1,0}. This generates a Clifford algebra isomorphic to the complex numbers.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.QFExterior","page":"API","title":"CliffordNumbers.QFExterior","text":"CliffordNumbers.QFExterior{R} (alias for QuadraticForm{0,0,R})\n\nThe quadratic form associated with an exterior algebra, which can be thought of as a Clifford  algebra where all dimensions are degenerate.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.QFNondegenerate","page":"API","title":"CliffordNumbers.QFNondegenerate","text":"CliffordNumbers.QFNondegenerate{P,Q} (alias for QuadraticForm{P,Q,0})\n\nRepresents a non-degenerate quadratic form (one without dimensions which square to 0).\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.QFPositiveDefinite","page":"API","title":"CliffordNumbers.QFPositiveDefinite","text":"CliffordNumbers.QFPositiveDefinite{P} (alias for QuadraticForm{P,0,0})\n\nA positive-definite quadratic form with P dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.QFReal","page":"API","title":"CliffordNumbers.QFReal","text":"CliffordNumbers.QFComplex\n\nThe quadratic form with zero dimensions, QuadraticForm{0,0,0}, isomorphic to the real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.QuadraticForm","page":"API","title":"CliffordNumbers.QuadraticForm","text":"CliffordNumbers.QuadratricForm\n\nRepresents a quadratric with P dimensions which square to +1, Q dimensions which square to -1, and R dimensions which square to 0, in that order.\n\nBy convention, this type is used as a tag, and is never instantiated.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.RepresentedGrades","page":"API","title":"CliffordNumbers.RepresentedGrades","text":"RepresentedGrades{C<:AbstractCliffordNumber} <: AbstractVector{Bool}\n\nA vector describing the grades explicitly represented by some Clifford number type C.\n\nIndexing of a RepresentedGrades{Q} is zero-based, with indices corresponding to all grades from 0 (scalar) to dimension(Q) (pseudoscalar), with true values indicating nonzero grades, and false indicating that the grade is zero.\n\nImplementation\n\nThe function nonzero_grades(::Type{T}) should be implemented for types T descending from  AbstractCliffordNumber.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.STA","page":"API","title":"CliffordNumbers.STA","text":"STA\n\nSpacetime algebra with a mostly negative signature (particle physicist's convention), Cl(1,3,0). An alias for QuadraticForm{1,3,0}.\n\nThe negative signature is used by default to distinguish this algebra from conformal geometric algebras, which use a mostly positive signature by convention.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.TransformedBitIndices","page":"API","title":"CliffordNumbers.TransformedBitIndices","text":"TransformedBitIndices{Q,C,F} <: AbstractBitIndices{Q,C}\n\nLazy representation of BitIndices{Q,C} with some function of type f applied to each element. These objects can be used to perform common operations which act on basis blades or grades, such as the reverse or grade involution.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CliffordNumbers.Z2CliffordNumber","page":"API","title":"CliffordNumbers.Z2CliffordNumber","text":"CliffordNumbers.Z2CliffordNumber{P,Q,T,L} <: AbstractCliffordNumber{Q,T}\n\nA Clifford number whose only nonzero grades are even or odd. Clifford numbers of this form naturally arise as versors, the geometric product of 1-vectors.\n\nThe type parameter P is constrained to be a Bool: true for odd grade Clifford numbers, and false for even grade Clifford numbers, corresponding to the Boolean result of each grade modulo 2.\n\nType aliases\n\nThis type is not exported, and usually you will want to refer to the following aliases:\n\nconst EvenCliffordNumber{Q,T,L} = Z2CliffordNumber{false,Q,T,L}\nconst OddCliffordNumber{Q,T,L} = Z2CliffordNumber{true,Q,T,L}\n\n\n\n\n\n","category":"type"},{"location":"api.html#Base.:*-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"API","title":"Base.:*","text":"*(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n(x::AbstractCliffordNumber{Q})(y::AbstractCliffordNumber{Q})\n\nCalculates the geometric product of x and y, returning the smallest type which is able to represent all nonzero basis blades of the result.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.:*-Union{Tuple{T}, Tuple{T, T}} where T<:BitIndex","page":"API","title":"Base.:*","text":"*(a::BitIndex{Q}, b::BitIndex{Q}) -> BitIndex{Q}\n\nReturns the BitIndex corresponding to the basis blade resulting from the geometric product of the basis blades indexed by a and b.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.abs-Tuple{AbstractCliffordNumber}","page":"API","title":"Base.abs","text":"abs2(x::CliffordNumber{Q,T}) -> Union{Real,Complex}\n\nCalculates the norm of x, equal to sqrt(scalar_product(x, ~x)).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.abs2-Tuple{AbstractCliffordNumber}","page":"API","title":"Base.abs2","text":"abs2(x::AbstractCliffordNumber{Q,T}) -> T\n\nCalculates the squared norm of x, equal to scalar_product(x, ~x).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.conj-Tuple{BitIndex}","page":"API","title":"Base.conj","text":"conj(i::BitIndex) -> BitIndex\nconj(x::AbstractCliffordNumber) -> typeof(x)\n\nCalculates the Clifford conjugate of the basis blade indexed by b or the Clifford number x. This is equal to grade_involution(reverse(x)).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.exp-Tuple{AbstractCliffordNumber}","page":"API","title":"Base.exp","text":"exp(x::AbstractCliffordNumber{Q})\n\nReturns the natural exponential of a Clifford number.\n\nFor special cases where m squares to a scalar, the following shortcuts can be used to calculate exp(x):\n\nWhen x^2 < 0: exp(x) === cos(abs(x)) + x * sin(abs(x)) / abs(x)\nWhen x^2 > 0: exp(x) === cosh(abs(x)) + x * sinh(abs(x)) / abs(x)\nWhen x^2 == 0: exp(x) == 1 + x\n\nSee also: exppi, exptau.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.muladd-Union{Tuple{T}, Tuple{Union{Real, Complex}, T, T}} where T<:AbstractCliffordNumber","page":"API","title":"Base.muladd","text":"muladd(x::Union{Real,Complex}, y::AbstractCliffordNumber{Q}, z::AbstractCliffordNumber{Q})\nmuladd(x::AbstractCliffordNumber{Q}, y::Union{Real,Complex}, z::AbstractCliffordNumber{Q})\n\nMultiplies a scalar with a Clifford number and adds another Clifford number using a more efficient operation than a juxtaposed multiply and add, if possible.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.real-Union{Tuple{AbstractCliffordNumber{Q, <:Real}}, Tuple{Q}} where Q","page":"API","title":"Base.real","text":"real(x::CliffordNumber{Q,T<:Real}) = T\n\nReturn the real (scalar) portion of a real Clifford number. \n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.reverse-Tuple{BitIndex}","page":"API","title":"Base.reverse","text":"reverse(i::BitIndex) -> BitIndex\nreverse(x::AbstractCliffordNumber) -> typeof(x)\n\nPerforms the reverse operation on the basis blade indexed by b or the Clifford number x. The  sign of the reverse depends on the grade, and is positive for g % 4 in 0:1 and negative for g % 4 in 2:3.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.sign-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{Type{QuadraticForm{P, Q, R}}, Integer}} where {P, Q, R}","page":"API","title":"Base.sign","text":"sign(::Type{QuadraticForm{P,Q,R}}, i::Integer) -> Int8\n\nGets the sign associated with dimension i of a quadratric form.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.widen-Union{Tuple{Type{<:AbstractCliffordNumber{Q, T}}}, Tuple{T}, Tuple{Q}} where {Q, T}","page":"API","title":"Base.widen","text":"widen(C::Type{<:AbstractCliffordNumber})\nwiden(x::AbstractCliffordNumber)\n\nConstruct a new type whose scalar type is widened. This behavior matches that of widen(C::Type{Complex{T}}), which results in widening of its scalar type T.\n\nFor obtaining a representation of a Clifford number with an increased number of nonzero grades, use widen_grade(T).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.CGA-Tuple{Any}","page":"API","title":"CliffordNumbers.CGA","text":"CGA(D) -> Type{QuadraticForm{D+1,1,0}}\n\nCreates the type of a quadratic form associated with a conformal geometric algebra (CGA) of dimension D.\n\nFor reasons of type stability, avoid calling this function without constant arguments.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.PGA-Tuple{Any}","page":"API","title":"CliffordNumbers.PGA","text":"PGA(D) -> Type{QuadraticForm{D,0,1}}\n\nCreates the type of a quadratic form associated with a projective geometric algebra (PGA) of dimension D.\n\nFor reasons of type stability, avoid calling this function without constant arguments.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.VGA-Tuple{Any}","page":"API","title":"CliffordNumbers.VGA","text":"VGA(D) -> Type{QuadraticForm{D,0,0}}\n\nCreates the type of a quadratic form associated with a vector/vanilla geometric algebra (VGA) of dimension D.\n\nFor reasons of type stability, avoid calling this function without constant arguments.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers._sort_with_parity!-Tuple{AbstractVector{<:Real}}","page":"API","title":"CliffordNumbers._sort_with_parity!","text":"CliffordNumbers._sort_with_parity!(v::AbstractVector{<:Real}) -> Tuple{typeof(v),Bool}\n\nPerforms a parity-tracking insertion sort of v, which modifies v in place. The function returns a tuple containing v and the parity, which is true for an odd permutation and false for an even permutation. This is implemented with a modified insertion sort algorithm.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.anticommutator-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"API","title":"CliffordNumbers.anticommutator","text":"anticommutator(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the anticommutator (or symmetric) product, equal to 1//2 * (x*y + y*x).\n\nNote that the dot product, in general, is not equal to the anticommutator product, which may be invoked with dot. In some cases, the preferred operators might be the left and right contractions, which use infix operators ⨼ and ⨽ respectively.\n\nType promotion\n\nBecause of the rational 1//2 factor in the product, inputs with scalar types subtyping Integer will be promoted to Rational subtypes.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.bitindex_shuffle-Union{Tuple{Q}, Tuple{L}, Tuple{BitIndex{Q}, Tuple{Vararg{BitIndex{Q}, L}}}} where {L, Q}","page":"API","title":"CliffordNumbers.bitindex_shuffle","text":"CliffordNumbers.bitindex_shuffle(a::BitIndex{Q}, B::NTuple{L,BitIndex{Q}})\nCliffordNumbers.bitindex_shuffle(a::BitIndex{Q}, B::BitIndices{Q})\n\nCliffordNumbers.bitindex_shuffle(B::NTuple{L,BitIndex{Q}}, a::BitIndex{Q})\nCliffordNumbers.bitindex_shuffle(B::BitIndices{Q}, a::BitIndex{Q})\n\nPerforms the multiplication -a * b for each element of B for the above ordering, or -b * a for the below ordering, generating a reordered NTuple of BitIndex{Q} objects suitable for implementing a geometric product.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.check_element_count-Tuple{Any, Any}","page":"API","title":"CliffordNumbers.check_element_count","text":"CliffordNumbers.check_element_count(sz, Q::Type{<:QuadraticForm}, [L], data)\n\nEnsures that the number of elements in data is the same as the result of f(Q), where f is a function that generates the expected number of elements for the type. This function is used in the inner constructors of subtypes of AbstractCliffordNumber{Q} to ensure that the input has the correct length.\n\nIf provided, the length type parameter L can be included as an argument, and it will be checked for type (must be an Int) and value (must be equal to sz).\n\nThis function returns nothing, but throws an AssertionError for failed checks.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.commutator-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"API","title":"CliffordNumbers.commutator","text":"commutator(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n×(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the commutator (or antisymmetric) product, equal to 1//2 * (x*y - y*x).\n\nNote that the commutator product, in general, is not equal to the wedge product, which may be invoked with the wedge function or the ∧ operator.\n\nType promotion\n\nBecause of the rational 1//2 factor in the product, inputs with scalar types subtyping Integer will be promoted to Rational subtypes.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.contraction-Union{Tuple{B}, Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, Val{B}}} where {Q, B}","page":"API","title":"CliffordNumbers.contraction","text":"CliffordNumbers.contraction(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q}, ::Val)\n\nGeneric implementation of left and right contractions as well as dot products. The left contraction is calculated if the final argument is Val(true); the right contraction is calcluated if the final argument is Val(false), and the dot product is calculated for any other Val.\n\nIn general, code should never refer to this method directly; use left_contraction, right_contraction, or dot if needed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.contraction_type-Union{Tuple{Q}, Tuple{K2}, Tuple{K1}, Tuple{Type{<:KVector{K1, Q}}, Type{<:KVector{K2, Q}}}} where {K1, K2, Q}","page":"API","title":"CliffordNumbers.contraction_type","text":"CliffordNumbers.contraction_type(::Type, ::Type)\n\nReturns the type of the contraction when performed on the input types. It only differs from CliffordNumbers.geometric_product_type when both inputs are KVector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.dot-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"API","title":"CliffordNumbers.dot","text":"dot(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the dot product of x and y.\n\nFor basis blades A of grade m and B of grade n, the dot product is equal to the left contraction when m >= n and is equal to the right contraction when n >= m.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.dual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q","page":"API","title":"CliffordNumbers.dual","text":"dual(x::CliffordNumber) -> CliffordNumber\n\nCalculates the dual of x, which is equal to the left contraction of x with the inverse of the pseudoscalar. However, \n\nNote that the dual has some properties that depend on the dimension and quadratic form:\n\nThe inverse of the unit pseudoscalar depends on the dimension of the space. Therefore, the\n\nperiodicity of \n\nIf the metric is degenerate, the dual is not unique.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.elementwise_product-Union{Tuple{C}, Tuple{Q}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, BitIndex{Q}, Bool}} where {Q, C<:(AbstractCliffordNumber{Q})}","page":"API","title":"CliffordNumbers.elementwise_product","text":"CliffordNumbers.elementwise_product(\n    [::Type{C},]\n    x::AbstractCliffordNumber{Q},\n    y::AbstractCliffordNumber{Q},\n    a::BitIndex{Q},\n    b::BitIndex{Q},\n    [condition = true]\n) where {Q,T<:AbstractCliffordNumber{Q}} -> C\n\nCalculates the geometric product between the element of x indexed by a and the element of y indexed by b. The result is returned as type C, but this can be inferred automatically if not provided.\n\nAn optional boolean condition can be provided, which simplifies the implementation of certain products derived from the geometric product.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.evil_number-Tuple{Integer}","page":"API","title":"CliffordNumbers.evil_number","text":"CliffordNumbers.evil_number(n::Integer)\n\nReturns the nth evil number, with the first evil number (n == 1) defined to be 0.\n\nEvil numbers are numbers which have an even Hamming weight (sum of its binary digits).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.exp_taylor-Union{Tuple{AbstractCliffordNumber}, Tuple{N}, Tuple{AbstractCliffordNumber, Val{N}}} where N","page":"API","title":"CliffordNumbers.exp_taylor","text":"CliffordNumbers.exp_taylor(x::AbstractCliffordNumber, order = Val(16))\n\nCalculates the exponential of x using a Taylor expansion up to the specified order. In most cases, 12 is as sufficient number.\n\nNotes\n\n16 iterations is currently used because the number of loop iterations is not currently a performance bottleneck.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.exponential_type-Union{Tuple{Type{C}}, Tuple{C}, Tuple{Q}} where {Q, C<:(AbstractCliffordNumber{Q})}","page":"API","title":"CliffordNumbers.exponential_type","text":"CliffordNumbers.exponential_type(::Type{<:AbstractCliffordNumber})\nCliffordNumbers.exponential_type(x::AbstractCliffordNumber)\n\nReturns the type expected when exponentiating a Clifford number. This is an EvenCliffordNumber if the nonzero grades of the input are even, a CliffordNumber otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.exppi-Tuple{AbstractCliffordNumber}","page":"API","title":"CliffordNumbers.exppi","text":"exppi(x::AbstractCliffordNumber)\n\nReturns the natural exponential of π * x with greater accuracy than exp(π * x) in the case where x^2 is a negative scalar, especially for large values of abs(x).\n\nSee also: exp, exptau.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.exptau-Tuple{AbstractCliffordNumber}","page":"API","title":"CliffordNumbers.exptau","text":"exptau(x::AbstractCliffordNumber)\n\nReturns the natural exponential of 2π * x with greater accuracy than exp(2π * x) in the case where x^2 is a negative scalar, especially for large values of abs(x).\n\nSee also: exp, exppi.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.geometric_product_type-Union{Tuple{C2}, Tuple{C1}, Tuple{Q}, Tuple{Type{C1}, Type{C2}}} where {Q, C1<:(AbstractCliffordNumber{Q}), C2<:(AbstractCliffordNumber{Q})}","page":"API","title":"CliffordNumbers.geometric_product_type","text":"CliffordNumbers.geometric_product_type(::Type{S}, ::Type{T})\n\nReturns the type of the result of the geometric product of the input types.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.getindex_as_tuple-Union{Tuple{C}, Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, BitIndices{Q, C}}} where {Q, C}","page":"API","title":"CliffordNumbers.getindex_as_tuple","text":"CliffordNumbers.getindex_as_tuple(x::AbstractCliffordNumber{Q}, B::BitIndices{Q,C})\n\nAn efficient method for indexing the elements of x into a tuple that can be used to construct a Clifford number of type C, or a similar type from CliffordNumbers.similar_type.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.grade-Union{Tuple{Type{<:KVector{K}}}, Tuple{K}} where K","page":"API","title":"CliffordNumbers.grade","text":"grade(::Type{<:KVector{K}}) = K\ngrade(x::KVector{K}) = k\n\nReturns the grade represented by a KVector{K}, which is K.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.grade_involution-Tuple{BitIndex}","page":"API","title":"CliffordNumbers.grade_involution","text":"grade_involution(i::BitIndex) -> BitIndex\ngrade_involution(x::AbstractCliffordNumber) -> typeof(x)\n\nCalculates the grade involution of the basis blade indexed by b or the Clifford number x. This effectively reflects all of the basis vectors of the space along their own mirror operation, which makes elements of odd grade flip sign.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.hamming_number-Tuple{Integer, Integer}","page":"API","title":"CliffordNumbers.hamming_number","text":"CliffordNumbers.hamming_number(w::Integer, n::Integer)\n\nGets the nth number with Hamming weight w. The first number with this Hamming weight (n = 1) is 2^w - 1.\n\nExample\n\njulia> CliffordNumbers.hamming_number(3, 2)\n11\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.has_grades_of-Union{Tuple{T}, Tuple{S}, Tuple{Type{S}, Type{T}}} where {S<:AbstractCliffordNumber, T<:AbstractCliffordNumber}","page":"API","title":"CliffordNumbers.has_grades_of","text":"has_grades_of(S::Type{<:AbstractCliffordNumber}, T::Type{<:AbstractCliffordNumber}) -> Bool\nhas_grades_of(x::AbstractCliffordNumber, y::AbstractCliffordNumber) -> Bool\n\nReturns true if the grades represented in S are also represented in T; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.has_wedge-Union{Tuple{Q}, Tuple{BitIndex{Q}, BitIndex{Q}}} where Q","page":"API","title":"CliffordNumbers.has_wedge","text":"CliffordNumbers.has_wedge(a::BitIndex{Q}, b::BitIndex{Q}, [c::BitIndex{Q}...]) -> Bool\n\nReturns true if the basis blades indexed by a, b, or any other blades c... have a nonzero wedge product; false otherwise. This is determined by comparing all bits of the arguments (except the sign bit) to identify any matching basis blades using bitwise AND.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.hestenes_product-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"API","title":"CliffordNumbers.hestenes_product","text":"hestenes_product(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nReturns the Hestenes product: this is equal to the dot product given by dot(x, y) but is equal to to zero when either x or y is a scalar.\n\nThis product is generally understood to lack utility; left and right contractions are preferred over this product in almost every case. It is implemented for the sake of completeness.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.is_same_blade-Union{Tuple{T}, Tuple{T, T}} where T<:BitIndex","page":"API","title":"CliffordNumbers.is_same_blade","text":"CliffordNumbers.is_same_blade(a::BitIndex{Q}, b::BitIndex{Q})\n\nChecks if a and b perform identical indexing up to sign.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.isevil-Tuple{Integer}","page":"API","title":"CliffordNumbers.isevil","text":"CliffordNumbers.isevil(i::Integer) -> Bool\n\nDetermines whether a number is evil, meaning that its Hamming weight (sum of its binary digits) is even.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.isodious-Tuple{Integer}","page":"API","title":"CliffordNumbers.isodious","text":"CliffordNumbers.isodious(i::Integer) -> Bool\n\nDetermines whether a number is odious, meaning that its Hamming weight (sum of its binary digits) is odd.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.ispseudoscalar-Tuple{AbstractCliffordNumber}","page":"API","title":"CliffordNumbers.ispseudoscalar","text":"ispseudoscalar(m::AbstractCliffordNumber)\n\nDetermines whether the Clifford number x is a pseudoscalar, meaning that all of its blades with grades below the dimension of the space are zero.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.isscalar-Tuple{AbstractCliffordNumber}","page":"API","title":"CliffordNumbers.isscalar","text":"isscalar(x::AbstractCliffordNumber)\n\nDetermines whether the Clifford number x is a scalar, meaning that all of its blades of nonzero grade are zero.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.left_contraction-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"API","title":"CliffordNumbers.left_contraction","text":"left_contraction(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n⨼(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the left contraction of x and y.\n\nFor basis blades A of grade m and B of grade n, the left contraction is zero if n < m, otherwise it is KVector{n-m,Q}(A*B).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.mul-Union{Tuple{T}, Tuple{Q}, Tuple{AbstractCliffordNumber{Q, T}, AbstractCliffordNumber{Q, T}}, Tuple{AbstractCliffordNumber{Q, T}, AbstractCliffordNumber{Q, T}, CliffordNumbers.GradeFilter}} where {Q, T}","page":"API","title":"CliffordNumbers.mul","text":"CliffordNumbers.mul(\n    x::Union{CliffordNumber{Q,T},Z2CliffordNumber{<:Any,Q,T}},\n    y::Union{CliffordNumber{Q,T},Z2CliffordNumber{<:Any,Q,T}},\n    [F::GradeFilter = GradeFilter{:*}()]\n)\n\nA fast geometric product implementation using generated functions for specific cases, and generic methods which either convert the arguments or fall back to other methods.\n\nThe arguments to this function should all agree in scalar type T. The * function, which exposes the fast geometric product implementation, promotes the scalar types of the arguments before utilizing this kernel.\n\nThe GradeFilter F allows for some blade multiplications to be excluded if they meet certain criteria. This is useful for implementing products besides the geometric product, such as the wedge product, which excludes multiplications between blades with shared vectors. Without a filter, this kernel just returns the geometric product.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.mul_mask-Union{Tuple{Q}, Tuple{L}, Tuple{CliffordNumbers.GradeFilter, BitIndex{Q}, Tuple{Vararg{BitIndex{Q}, L}}}} where {L, Q}","page":"API","title":"CliffordNumbers.mul_mask","text":"CliffordNumbers.mul_mask(F::GradeFilter, a::BitIndex{Q}, B::NTuple{L,BitIndices{Q}})\nCliffordNumbers.mul_mask(F::GradeFilter, B::NTuple{L,BitIndices{Q}}, a::BitIndex{Q})\n\nCliffordNumbers.mul_mask(F::GradeFilter, a::BitIndex{Q}, B::BitIndices{Q})\nCliffordNumbers.mul_mask(F::GradeFilter, B::BitIndices{Q}, a::BitIndex{Q})\n\nGenerates a NTuple{L,Bool} which is true whenever the multiplication of the blade indexed by a and blades indexed by B is nonzero. false is returned if the grades multiply to zero due to the squaring of a degenerate component, or if they are filtered by F.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.next_of_hamming_weight-Tuple{Integer}","page":"API","title":"CliffordNumbers.next_of_hamming_weight","text":"CliffordNumbers.next_of_hamming_weight(n::Integer)\n\nReturns the next integer with the same Hamming weight as n.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.nondegenerate_mask-Union{Tuple{Q}, Tuple{L}, Tuple{BitIndex{Q}, Tuple{Vararg{BitIndex{Q}, L}}}} where {L, Q}","page":"API","title":"CliffordNumbers.nondegenerate_mask","text":"CliffordNumbers.nondegenerate_mask(a::BitIndex{Q}, B::NTuple{L,BitIndex{Q}})\n\nConstructs a Boolean mask which is false for any multiplication that squares a degenerate blade; true otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.nondegenerate_mult-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{BitIndex{QuadraticForm{P, Q, R}}, BitIndex{QuadraticForm{P, Q, R}}}} where {P, Q, R}","page":"API","title":"CliffordNumbers.nondegenerate_mult","text":"CliffordNumbers.nondegenerate_mult(a::T, b::T) where T<:BitIndex{QuadraticForm{P,Q,R}} -> Bool\n\nReturns false if the product of a and b is zero due to the squaring of a degenerate component, true otherwise. This function always returns true if R === 0.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.nondegenerate_square-Union{Tuple{BitIndex{QuadraticForm{P, Q, R}}}, Tuple{R}, Tuple{Q}, Tuple{P}} where {P, Q, R}","page":"API","title":"CliffordNumbers.nondegenerate_square","text":"CliffordNumbers.nondegenerate_square(b::BitIndex) -> Bool\n\nReturns false if squaring the basis blade b is zero due to a degenerate component, true  otherwise. For a nondegenerate metric, this is always true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.nonzero_grades-Tuple{Number}","page":"API","title":"CliffordNumbers.nonzero_grades","text":"nonzero_grades(::Type{<:AbstractCliffordNumber})\nnonzero_grades(::AbstractCliffordNumber)\n\nA function returning an indexable object representing all nonzero grades of a Clifford number representation.\n\nThis function is used to define the indexing of RepresentedGrades, and should be defined for any subtypes of AbstractCliffordNumber.\n\nExamples\n\njulia> CliffordNumbers.nonzero_grades(CliffordNumber{APS})\n0:3\n\njulia> CliffordNumbers.nonzero_grades(KVector{2,APS})\n2:2\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.normalize-Tuple{AbstractCliffordNumber}","page":"API","title":"CliffordNumbers.normalize","text":"normalize(x::AbstractCliffordNumber{Q}) -> AbstractCliffordNumber{Q}\n\nNormalizes x so that its magnitude (as calculated by abs2(x)) is 1.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.number_of_parity-Tuple{Integer, Bool}","page":"API","title":"CliffordNumbers.number_of_parity","text":"CliffordNumbers.number_of_parity(n::Integer, modulo::Bool)\n\nReturns the nth number whose Hamming weight is even (for modulo = false) or odd (for modulo = true).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.numeric_type-Tuple{Type}","page":"API","title":"CliffordNumbers.numeric_type","text":"numeric_type(::Type{<:AbstractCliffordNumber{Q,T}}) = T\nnumeric_type(T::Type{<:Union{Real,Complex}}) = T\nnumeric_type(x) = numeric_type(typeof(x))\n\nReturns the numeric type associated with an AbstractCliffordNumber instance. For subtypes of Real and Complex, or their instances, this simply returns the input type or instance type.\n\nWhy not define eltype?\n\nAbstractCliffordNumber instances behave like numbers, not arrays. If collect() is called on a Clifford number of type T, it should not construct a vector of coefficients; instead it should return an Array{T,0}. Similarly, a broadcasted multiplication should return the same result as normal multiplication, as is the case with complex numbers.\n\nFor subtypes T of Number, eltype(T) === T, and this is true for AbstractCliffordNumber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.odious_number-Tuple{Integer}","page":"API","title":"CliffordNumbers.odious_number","text":"CliffordNumbers.odious_number(n::Integer)\n\nReturns the nth odious number, with the first odious number (n == 1) defined to be 1.\n\nOdious numbers are numbers which have an odd Hamming weight (sum of its binary digits).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.product_at_index-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, BitIndex{Q}, Any}} where Q","page":"API","title":"CliffordNumbers.product_at_index","text":"CliffordNumbers.product_at_index(\n    x::AbstractCliffordNumber{Q},\n    y::AbstractCliffordNumber{Q},\n    i::BitIndex{Q}\n    [f = Returns(true)]\n)\n\nCalculate the coefficient indexed by i from Clifford numbers x and y. The optional function f determines whether the result of a particular pair of indices is used to calculate the result.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.product_kernel-Union{Tuple{C}, Tuple{Q}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}, Tuple{Type{C}, AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}, Any}} where {Q, C<:(AbstractCliffordNumber{Q})}","page":"API","title":"CliffordNumbers.product_kernel","text":"CliffordNumbers.product_kernel(\n    ::Type{T},\n    x::AbstractCliffordNumber{Q},\n    y::AbstractCliffordNumber{Q},\n    [f = Returns(true)]\n)\n\nSums the products of each pair of nonzero basis blades of x and y. This can be used to to implement various products by supplying a function f which acts on the indices of x and y to return a Bool, and the product of the basis blades is excluded if it evaluates to true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.product_return_type-Union{Tuple{C2}, Tuple{C1}, Tuple{Q}, Tuple{Type{C1}, Type{C2}, CliffordNumbers.GradeFilter}} where {Q, C1<:(AbstractCliffordNumber{Q}), C2<:(AbstractCliffordNumber{Q})}","page":"API","title":"CliffordNumbers.product_return_type","text":"CliffordNumbers.product_return_type(::Type{X}, ::Type{Y}, [::GradeFilter{S}])\n\nReturns a suitable type for representing the product of Clifford numbers of types X and Y. The GradeFilter{S} argument allows for the return type to be changed depending on the type of product. Without specialization on S, a type suitable for the geometric product is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.promote_numeric_type-Tuple{}","page":"API","title":"CliffordNumbers.promote_numeric_type","text":"promote_numeric_type(x, y)\n\nCalls promote_type() for the result of numeric_type() called on all arguments. For incompletely specified types, the result of numeric_type() is replaced with Bool, which always promotes to any larger numeric type.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.pseudoscalar_index-Union{Tuple{Type{Q}}, Tuple{Q}} where Q<:QuadraticForm","page":"API","title":"CliffordNumbers.pseudoscalar_index","text":"pseudoscalar_index(x::AbstractCliffordNumber{Q}) -> BitIndex{Q}\n\nConstructs the BitIndex used to obtain the pseudoscalar (highest grade) portion of x.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.right_contraction-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"API","title":"CliffordNumbers.right_contraction","text":"right_contraction(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n⨽(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the right contraction of x and y.\n\nFor basis blades A of grade m and B of grade n, the right contraction is zero if m < n, otherwise it is KVector{m-n,Q}(A*B).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.sandwich-Union{Tuple{Q}, Tuple{CliffordNumber{Q}, CliffordNumber{Q}}} where Q","page":"API","title":"CliffordNumbers.sandwich","text":"sandwich(x::CliffordNumber{Q}, y::CliffordNumber{Q})\n\nCalculates the sandwich product of x with y: ~y * x * y, but with corrections for numerical stability. \n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.scalar_convert-Union{Tuple{T}, Tuple{Type{T}, AbstractCliffordNumber}} where T<:Union{Real, Complex}","page":"API","title":"CliffordNumbers.scalar_convert","text":"scalar_convert(T::Type{<:Union{Real,Complex}}, x::AbstractCliffordNumber) -> T\nscalar_convert(T::Type{<:Union{Real,Complex}}, x::Union{Real,Complex}) -> T\n\nIf x is an AbstractCliffordNumber, converts the scalars of x to type T.\n\nIf x is a Real or Complex, converts x to T.\n\nExamples\n\njulia> scalar_convert(Float32, KVector{1,APS}(1, 2, 3))\n3-element KVector{1, VGA(3), Float32}:\n1.0σ₁ + 2.0σ₂ + 3.0σ\n\njulia> scalar_convert(Float32, 2)\n2.0f0\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.scalar_index-Union{Tuple{Type{Q}}, Tuple{Q}} where Q<:QuadraticForm","page":"API","title":"CliffordNumbers.scalar_index","text":"scalar_index(x::AbstractCliffordNumber{Q}) -> BitIndex{Q}()\n\nConstructs the BitIndex used to obtain the scalar (grade zero) portion of x.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.scalar_product-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"API","title":"CliffordNumbers.scalar_product","text":"scalar_product(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the scalar product of two Clifford numbers with quadratic form Q. The result is a Real or Complex number. This can be converted back to an AbstractCliffordNumber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.scalar_promote-Tuple{}","page":"API","title":"CliffordNumbers.scalar_promote","text":"scalar_promote(x::AbstractCliffordNumber, y::AbstractCliffordNumber)\n\nPromotes the scalar types of x and y to a common type. This does not increase the number of represented grades of either x or y.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.select_grade-Tuple{CliffordNumber, Integer}","page":"API","title":"CliffordNumbers.select_grade","text":"select_grade(x::CliffordNumber, g::Integer)\n\nReturns a multivector similar to x where all elements not of grade g are equal to zero.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.short_typename-Tuple{AbstractCliffordNumber}","page":"API","title":"CliffordNumbers.short_typename","text":"CliffordNumbers.short_name(T::Type{<:AbstractCliffordNumber})\nCliffordNumbers.short_name(x::AbstractCliffordNumber})\n\nReturns a type with a shorter name than T, but still constructs T. This is achieved by removing dependent type parameters; often this includes the length parameter.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.sign_of_mult-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{BitIndex{QuadraticForm{P, Q, R}}, BitIndex{QuadraticForm{P, Q, R}}}} where {P, Q, R}","page":"API","title":"CliffordNumbers.sign_of_mult","text":"CliffordNumbers.sign_of_mult(a::T, b::T) where T<:BitIndex{QuadraticForm{P,Q,R}} -> Int8\n\nReturns an Int8 that carries the sign associated with the multiplication of two basis blades of Clifford/geometric algebras of the same quadratic form.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.sign_of_square-Tuple{BitIndex}","page":"API","title":"CliffordNumbers.sign_of_square","text":"CliffordNumbers.sign_of_square(b::BitIndex) -> Int8\n\nReturns the sign associated with squaring the basis blade indexed by b using an Int8 as proxy: positive signs return Int8(1), negative signs return Int8(-1), and zeros from degenerate components return Int8(0).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.signbit_of_mult-Tuple{Unsigned, Unsigned}","page":"API","title":"CliffordNumbers.signbit_of_mult","text":"CliffordNumbers.signbit_of_mult(a::Integer, [b::Integer]) -> Bool\nCliffordNumbers.signbit_of_mult(a::BitIndex, [b::BitIndex]) -> Bool\n\nCalculates the sign bit associated with multiplying basis elements indexed with bit indices supplied as either integers or BitIndex instances. The sign bit flips when the order of a and b are reversed, unless a === b. \n\nAs with Base.signbit(), true represents a negative sign and false a positive sign. However, in degenerate metrics (such as those of projective geometric algebras) the sign bit may be irrelevant as the multiplication of those basis blades would result in zero.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.signbit_of_square-Union{Tuple{BitIndex{QuadraticForm{P, Q, R}}}, Tuple{R}, Tuple{Q}, Tuple{P}} where {P, Q, R}","page":"API","title":"CliffordNumbers.signbit_of_square","text":"CliffordNumbers.signbit_of_square(b::BitIndex) -> Bool\n\nReturns the signbit associated with squaring the basis blade indexed by b.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.signmask","page":"API","title":"CliffordNumbers.signmask","text":"CliffordNumbers.signmask([T::Type{<:Integer} = UInt], [signbit::Bool = true]) -> T\n\nGenerates a signmask, or a string of bits where the only 1 bit is the sign bit. If signbit is set to false, this returns zero (or whatever value is represented by all bits being 0).\n\n\n\n\n\n","category":"function"},{"location":"api.html#CliffordNumbers.similar_type-Tuple{AbstractCliffordNumber, Type{<:Union{Real, Complex}}, Type{<:QuadraticForm}}","page":"API","title":"CliffordNumbers.similar_type","text":"CliffordNumbers.similar_type(\n    C::Type{<:AbstractCliffordNumber},\n    [N::Type{<:BaseNumber} = numeric_type(C)],\n    [Q::Type{<:QuadraticForm} = QuadraticForm(C)]\n) -> Type{<:AbstractCliffordNumber{Q,N}}\n\nConstructs a type similar to T but with numeric type N and quadratic form Q.\n\nThis function must be defined with all its arguments for each concrete type subtyping AbstractCliffordNumber.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.subscript_string-Tuple{Number}","page":"API","title":"CliffordNumbers.subscript_string","text":"CliffordNumbers.subscript_string(x::Number) -> String\n\nProduces a string representation of a number in subscript format.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.to_basis_str-Union{Tuple{BitIndex{Q}}, Tuple{Q}} where Q","page":"API","title":"CliffordNumbers.to_basis_str","text":"CliffordNumbers.to_basis_str(b::BitIndex; [label], [pseudoscalar])\n\nCreates a string representation of the basis element given by b.\n\nThe label parameter determines the symbol used for every basis element. In general, this defaults to e, but a few special cases use different symbols:\n\nFor the algebra of physical space, σ is used.\nFor the spacetime algebras of either signature, γ is used.\n\nIf pseudoscalar is set, the pseudoscalar may be printed using a different symbol from the rest of the basis elements.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.undual-Union{Tuple{CliffordNumber{Q}}, Tuple{Q}} where Q","page":"API","title":"CliffordNumbers.undual","text":"undual(x::CliffordNumber) -> CliffordNumber\n\nCalculates the undual of x, which is equal to the left contraction of x with the pseudoscalar. This function can be used to reverse the behavior of dual().\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.versor_inverse-Tuple{CliffordNumber}","page":"API","title":"CliffordNumbers.versor_inverse","text":"versor_inverse(x::CliffordNumber)\n\nCalculates the versor inverse of x, equal to x / scalar_product(x, ~x), so that x * inv(x) == inv(x) * x == 1.\n\nThe versor inverse is only guaranteed to be an inverse for blades and versors. Not all Clifford numbers have a well-defined inverse, since Clifford numbers have zero divisors (for instance, in the algebra of physical space, 1 + e₁ has a zero divisor).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.wedge-Union{Tuple{Q}, Tuple{AbstractCliffordNumber{Q}, AbstractCliffordNumber{Q}}} where Q","page":"API","title":"CliffordNumbers.wedge","text":"wedge(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n∧(x::AbstractCliffordNumber{Q}, y::AbstractCliffordNumber{Q})\n\nCalculates the wedge (outer) product of two Clifford numbers x and y with quadratic form Q.\n\nNote that the wedge product, in general, is not equal to the commutator product (or antisymmetric product), which may be invoked with the commutator function or the × operator.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.wedge_product_type-Union{Tuple{Q}, Tuple{K2}, Tuple{K1}, Tuple{Type{<:KVector{K1, Q}}, Type{<:KVector{K2, Q}}}} where {K1, K2, Q}","page":"API","title":"CliffordNumbers.wedge_product_type","text":"CliffordNumbers.wedge_product_type(::Type, ::Type)\n\nReturns the type of the result of the wedge product of the input types. It only differs from CliffordNumbers.geometric_product_type when both inputs are KVector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.widen_grade-Tuple{AbstractCliffordNumber}","page":"API","title":"CliffordNumbers.widen_grade","text":"widen_grade(C::Type{<:AbstractCliffordNumber})\nwiden_grade(x::AbstractCliffordNumber)\n\nFor type arguments, construct the next largest type that can hold all of the grades of C. KVector{K,Q,T} widens to EvenCliffordNumber{Q,T} or OddCliffordNumber{Q,T}, and EvenCliffordNumber{Q,T} and OddCliffordNumber{Q,T} widen to CliffordNumber{Q,T}, which is the widest type.\n\nFor AbstractCliffordNumber arguments, the argument is converted to the result of widen_grade(typeof(x)).\n\nFor widening the scalar type of an AbstractCliffordNumber, use Base.widen(T).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.widen_grade_for_mul-Tuple{Union{CliffordNumber, CliffordNumbers.Z2CliffordNumber}}","page":"API","title":"CliffordNumbers.widen_grade_for_mul","text":"CliffordNumbers.widen_for_mul(x::AbstractCliffordNumber)\n\nWidens x to an EvenCliffordNumber, OddCliffordNumber, or CliffordNumber as appropriate for the fast multiplication kernel.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.zero_tuple-Union{Tuple{L}, Tuple{T}, Tuple{Type{T}, Val{L}}} where {T, L}","page":"API","title":"CliffordNumbers.zero_tuple","text":"CliffordNumbers.zero_tuple(::Type{T}, ::Val{L}) -> NTuple{L,T}\n\nGenerates a Tuple of length L with all elements being zero(T).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CliffordNumbers.zero_tuple-Union{Tuple{Type{C}}, Tuple{C}} where C<:AbstractCliffordNumber","page":"API","title":"CliffordNumbers.zero_tuple","text":"CliffordNumbers.zero_tuple(::Type{C<:AbstractCliffordNumber})\n    -> NTuple{length(C),numeric_type(C)}\n\nGenerates a Tuple that can be used to construct zero(C).\n\n\n\n\n\n","category":"method"},{"location":"getting_started.html#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started.html#The-CliffordNumber-data-type","page":"Getting started","title":"The CliffordNumber data type","text":"","category":"section"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"A CliffordNumber{Q,T,L} is a Clifford number associated with a QuadraticForm Q, a backing Real or Complex type T, and a length L. The length parameter is redundant, and in many cases, it may be omitted without consequence.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"!!! warning Although the length may be omitted in many cases, it's important to remember that a CliffordNumber{Q,T} is not a concrete type. This is important when creating an Array or other container of CliffordNumber elements.","category":"page"},{"location":"getting_started.html#Internals","page":"Getting started","title":"Internals","text":"","category":"section"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"A CliffordNumber{Q,T,L} is backed by an NTuple{L,T} where T<:Union{Real,Complex}. The coefficients, however, are not indexed in grade order as is done canonically in most resources.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"!!! danger Read that again: CliffordNumber indexing is not done in grade order.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"Instead, the coefficients are arranged in a binary counted fashion, which allows for better SIMD optimization.","category":"page"},{"location":"getting_started.html#Constructing-a-Clifford-number","page":"Getting started","title":"Constructing a Clifford number","text":"","category":"section"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"The inner constructor for CliffordNumber is CliffordNumber{Cl,T,L}(x), where x is any type that can be converted to an NTuple{L,T}. However, in many cases, the type parameters are redundant, particularly L. For this reason, more constructors exist.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"In general, one can use a Vararg constructor to directly input the values.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"julia> CliffordNumber{APS}(1, 2, 3, 4, 5, 6, 7, 8)\nCliffordNumber{APS,Int}(1, 2, 3, 4, 5, 6, 7, 8)","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"Clifford numbers may also be constructed from real numbers, generating a scalar-valued CliffordNumber:","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"julia> CliffordNumber{APS}(1)\nCliffordNumber{APS,Int}(1, 0, 0, 0, 0, 0, 0, 0)","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"When constructing a CliffordNumber from complex numbers, the type parameters become more important. By default, it is assumed that the element type of a CliffordNumber is a Real. If a complex CliffordNumber is desired, this must be stated explicitly.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"julia> CliffordNumber{APS}(1 + im)\nCliffordNumber{APS,Int}(1, 0, 0, 0, 0, 0, 0, 1)\n\njulia> CliffordNumber{APS,Complex}(1 + im)\nCliffordNumber{APS,Complex{Int}}(1 + im, 0, 0, 0, 0, 0, 0, 0)","category":"page"},{"location":"getting_started.html#Quadratic-forms","page":"Getting started","title":"Quadratic forms","text":"","category":"section"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"Before getting started with Clifford numbers, it's important to understand how the dimensionality of the space is stored. Unlike with other data types such as StaticArrays.jl's SVector, the total number of dimensions in the space is not all the information that needs to be stored. Each basis vector of the space may square to a positive number, negative number, or zero, defining the quadratic form associated with the Clifford algebra. This information needs to be tracked as a type parameter for CliffordNumber.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"To handle this, the QuadraticForm{P,Q,R} type is used to store information about the quadratic form. In this type, P represents the number of dimensions squaring to a positive number, Q represents the number squaring to a negative number, and R represents the number squaring to zero.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"!!! note By convention, the QuadraticForm type is not instantiated when used as a type parameter for CliffordNumber instances.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"CliffordNumbers.jl provides the following aliases for common algebras:","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"| Algebra    | Alias                  | Note                                           | | VGA(D)   | QuadraticForm{D,0,0} | Vanilla/vector geometric algebra               | | PGA(D)   | QuadraticForm{D,0,1} | Projective geometric algebra                   | | APS      | QuadraticForm{3,0,0} | Algebra of physical space                      | | STA      | QuadraticForm{1,3,0} | Spacetime algebra. By default, uses a +–-     | |            |                        | convention to distinguish it from a conformal  | |            |                        | geometric algebra.                             |","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"Currently, an alias for conformal geometric algebras (CGA{D}) does not exist, as it requires some type parameter trickery that hasn't been figured out yet.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = CliffordNumbers","category":"page"},{"location":"index.html#CliffordNumbers","page":"Home","title":"CliffordNumbers","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"CliffordNumbers.jl is a package that provides fully static multivectors (Clifford numbers) in arbitrary dimensions and metrics. While in many cases, sparse representations of multivectors are more efficient, for spaces of low dimension, dense static representations may provide a performance and convenience advantage.","category":"page"},{"location":"index.html#Design-goals","page":"Home","title":"Design goals","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The goal of this package is to provide a multivector implementation that:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Allows for the construction of multivectors in arbitrary metrics, with coefficients that subtype any instance of Real or Complex.\nProvides data structures of fixed sizes that represent multivectors. This allows for instances to be allocated on the stack or stored inline in an Array rather than as pointers to individually allocated instances.\nProvides dense representations of multivectors, as well as convenient sparse representations, which can be constructed from each other, converted in a way that guarantees representability, and allows for promotion between instances.\nSubtypes Number: The term \"Clifford number\" emphasizes the perspective of multivectors as an extension of the real numbers, in the same way that complex numbers and quaternions extend them. (It should be noted that both complex numbers and quaternions are Clifford algebras!)\nAggressively optimizes all mathematical operations, utilizing fma operations and SIMD instructions whenever possible.\nInteroperates with automatic differentiation tools and other packages which allow for the implementation of operations from geometric calculus.","category":"page"},{"location":"operations.html#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"Like with other numbers, standard mathematical operations are supported that relate Clifford numbers to elements of their scalar field and to each other.","category":"page"},{"location":"operations.html#Unary-operations","page":"Operations","title":"Unary operations","text":"","category":"section"},{"location":"operations.html#Grade-automorphisms","page":"Operations","title":"Grade automorphisms","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"Grade automorphisms are operations which preserves the grades of each basis blade, but changes their sign depending on the grade. All of these operations are their own inverse.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"All grade automorphisms are applicable to BitIndex objects, and the way they are implemented is through constructors that use TransformedBitIndices objects to alter each grade.","category":"page"},{"location":"operations.html#Reverse","page":"Operations","title":"Reverse","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"The reverse is an operation which reverses the order of the wedge product that constructed each basis blade. This is implemented with methods for Base.reverse and Base.:~.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"note: Syntax changes\nIn the future, Base.:~ will no longer be used for this operation; instead Base.adjoint will be overloaded, providing ' as a syntax for the reverse.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"This is the most commonly used automorphism, and in a sense can be thought of as equivalent to complex conjugation. When working with even elements of the algebras of 2D or 3D space, this behaves identically to complex conjugation and quaternion conjugation. However, this is not the case when working in the even subalgebras.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"Base.reverse(::BitIndex)","category":"page"},{"location":"operations.html#Grade-involution","page":"Operations","title":"Grade involution","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"Grade involution changes the sign of all odd grades, an operation equivalent to mirroring every basis vector of the space. This can be acheived with the grade_involution function.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"When interpreting even multivectors as elements of the even subalgebra of the algebra of interest, the grade involution in the even subalgebra is equivalent to the reverse in the algebra of interest.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"Grade involution is equivalent to complex conjugation in when dealing with the even subalgebra of 2D space, which is isomorphic to the complex numbers, but this is not true for quaternion conjugation. Instead, use the Clifford conjugate (described below).","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"CliffordNumbers.grade_involution(::BitIndex)","category":"page"},{"location":"operations.html#Clifford-conjugation","page":"Operations","title":"Clifford conjugation","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"The Clifford conjugate is the combination of the reverse and grade involution. This is available via an overload of Base.conj.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"warning: Warning\nconj(::AbstractCliffordNumber) implements the Clifford conjugate, not the reverse!","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"When dealing with the even subalgebras of 2D and 3D VGAs, which are isomorphic to the complex numbers and quaternions, respectively, the Clifford conjugate is equivalent to complex conjugation or quaternion conjugation. Otherwise, this is a less widely used operation than the above two.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"Base.conj(::BitIndex)","category":"page"},{"location":"operations.html#Binary-operations","page":"Operations","title":"Binary operations","text":"","category":"section"},{"location":"operations.html#Addition-and-subtraction","page":"Operations","title":"Addition and subtraction","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"Addition and subtraction work as expected for Clifford numbers just as they do for other numbers. The promotion system handles all cases where objects of mixed type are added.","category":"page"},{"location":"operations.html#Products","page":"Operations","title":"Products","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"Clifford algebras admit a variety of products. Common ones are implemented with infix operators.","category":"page"},{"location":"operations.html#Geometric-product","page":"Operations","title":"Geometric product","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"The geometric product, or Clifford product, is the defining product of the Clifford algebra. This is implemented with the usual multiplication operator *, but it is also possible to use parenthetical notation as it is with real numbers.","category":"page"},{"location":"operations.html#Wedge-product","page":"Operations","title":"Wedge product","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"The wedge product is the defining product of the exterior algebra. This is available with the wedge() function, or with the ∧ infix operator.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"tip: Tip\nYou can define elements of exterior algebras directly by using QuadraticForm{0,0,R}, whose geometric product is equivalent to the wedge product.","category":"page"},{"location":"operations.html#Contractions-and-dot-products","page":"Operations","title":"Contractions and dot products","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"The contraction operations generalize the dot product of vectors to Clifford numbers. While it is possible to define a symmetric dot product (and one is provided in this package), the generalization of the dot product to Clifford numbers is naturally asymmetric in cases where the grade of one input blade is not equal to that of the other.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"For Clifford numbers x and y, the left contraction x ⨼ y describes the result of projecting x onto the space spanned by y. If x and y are homogeneous in grade, this product is equal to the geometric product if grade(y) ≥ grade(x), and zero otherwise. For general multivectors, the left contraction can be calculated by applying this rule to the products of their basis blades.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"The analogous right contraction is only nonzero if grade(x) ≥ grade(y), and it can be calculated with ⨽.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"The dot product is a symmetric variation of the left and right contractions, and provides a looser constraint on the basis blades: grade(dot(x,y)) must equal abs(grade(x) - grade(y)). The  Hestenes dot product is equivalent to the dot product above, but is zero if either x or y is a scalar.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"warn: Warn\nCurrently, the dot product is implemented with the exported function CliffordNumbers.dot. However, this package does not depend on LinearAlgebra, so there will be a name conflict between the methods defined by this package and those defined by LinearAlgebra.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"Contractions are generally favored over the dot products due to their nicer properties. It is generally recommended that the Hestenes dot product be avoided, though it is included in this library for the sake of completeness.","category":"page"},{"location":"operations.html#Commutator-and-anticommutator-products","page":"Operations","title":"Commutator and anticommutator products","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"The commutator product (or antisymmetric product) of Clifford numbers x and y, denoted x × y, is equal to 1//2 * (x*y - y*x). This product is nonzero if the geometric product of x  and y does not commute, and the value represents the degree to which they fail to commute.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"The commutator product is the building block of Lie algebras; in particular, the commutator products of bivectors, which are also bivectors. With the bivectors of 3D space, the Lie algebra is equivalent to that generated by the cross product, hence the × notation.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"The analogous anticommutator product (or symmetric product) is 1//2 * (x*y + y*x). This uses the ⨰ operator, which is not an operator generally used for this purpose, but was selected as it looks similar to the commutator product, with the dot indicating the similarity with the dot product, which is also symmetric.","category":"page"},{"location":"operations.html#Defining-new-products:-Multiplication-internals","page":"Operations","title":"Defining new products: Multiplication internals","text":"","category":"section"},{"location":"operations.html","page":"Operations","title":"Operations","text":"Products are implemented with the fast multiplication kernel CliffordNumbers.mul, which accepts two Clifford numbers with the same scalar type and a CliffordNumbers.GradeFilter object. This GradeFilter object defines a method that takes two or more BitIndex objects and returns false if their product is constrained to be zero.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"CliffordNumbers.mul requires that the coefficient types of the numbers being multiplied are the same. Methods which leverage CliffordNumbers.mul should promote the coefficient types of the arguments to a common type using scalar_promote before passing them to the kernel. Any further promotion needed to return the final result is handled by the kernel.","category":"page"},{"location":"operations.html","page":"Operations","title":"Operations","text":"In general, it is also strongly recommended to promote the types of the arguments to CliffordNumbers.Z2CliffordNumber or CliffordNumber for higher performance. Currently, the implementation of CliffordNumbers.mul is asymmetric, and does not consider which input is longer. Even in the preferred order, we find that KVector incurs a significant performance penalty.","category":"page"},{"location":"types.html#Numeric-types","page":"Types","title":"Numeric types","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"This package exports a variety of types that represents elements of Clifford algebras.","category":"page"},{"location":"types.html#AbstractCliffordNumber{Q,T}","page":"Types","title":"AbstractCliffordNumber{Q,T}","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"The AbstractCliffordNumber{Q,T} type is the supertype for all implmentations of Clifford numbers. Q is a QuadraticForm, which describes the number of dimensions with positive, negative, and zero square, and T is a Union{Real,Complex} type of the coefficients.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"CliffordNumbers.AbstractCliffordNumber","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"!!! note \"Future StaticCliffordNumber{Q,T,L} type     We may introduce a new abstract type, StaticCliffordNumber{Q,T,L}, for static implementations,     like all of the ones provided by this package. These should be implemented as fixed length data     structures (ideally an NTuple{L,T}).","category":"page"},{"location":"types.html#CliffordNumber{Q,T,L}:-full-grade-Clifford-numbers","page":"Types","title":"CliffordNumber{Q,T,L}: full grade Clifford numbers","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"CliffordNumber{Q,T,L} is the largest possible representation of a Clifford number, and it  explicitly includes the coefficients for all 2^dimension(Q) basis blades.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"While this type is useful if working with objects that mix even and odd grades (for instance, projectors or left minimal ideals), it is often more efficient to work with a smaller type, like the ones described below.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"CliffordNumbers.CliffordNumber","category":"page"},{"location":"types.html#EvenCliffordNumber{Q,T,L}-and-OddCliffordNumber{Q,T,L}","page":"Types","title":"EvenCliffordNumber{Q,T,L} and OddCliffordNumber{Q,T,L}","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"These types represent Clifford numbers of exclusively even or odd grade, respectively.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"Internally, these are the same type: they alias CliffordNumbers.Z2CliffordNumber{P,Q,T,L}, where P is a Boolean parameter which is false for EvenCliffordNumber and true for OddCliffordNumber.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"CliffordNumbers.EvenCliffordNumber\nCliffordNumbers.OddCliffordNumber\nCliffordNumbers.Z2CliffordNumber","category":"page"},{"location":"types.html#KVector{K,Q,T,L}","page":"Types","title":"KVector{K,Q,T,L}","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"This type represents a k-vector, or a Clifford number of homogeneous grade, with the parameter K indicating the grade.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"It should be noted that in general, this type is not as efficient as EvenCliffordNumber, OddCliffordNumber, or CliffordNumber when calculating products (though this may change in the  future). Use this type if your primary operations are addition, or if you need compact storage.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"However, there is one exception to this: KVector{0}, which represents a scalar. This type has been optimized so that operations with it are simply converted to scalar operations.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"warning: Warning\nIt is important to note that k-vectors are not k-blades (the wedge product of k 1-vectors) or k-versors (the geometric product of k 1-vectors). In dimensions up to 3, all k-vectors are also k-blades, but this is not generally true: as a counterexample, e_1 e_2 + e_3 e_4 is not representable as a k-blade. However, all k-blades are k-vectors.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"CliffordNumbers.KVector","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"note: Note\nIn the future, we may consider adding a DualKVector or PseudoKVector type to more easily represent pseudoscalars, pseudovectors, and related objects.","category":"page"},{"location":"types.html#Promotion-and-widening","page":"Types","title":"Promotion and widening","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"This package provides a robust promotion system for converting Clifford numbers and scalars to common types before performing common numeric operations.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"When promoting the types of Clifford numbers, there are two different types of promotions that can occur: scalar promotions, which promote all the scalar types of the arguments to a common scalar type, and grade promotions, which promote all the arguments to types which have a common set of grades. This package provides the scalar_promote function that allows for the scalar types of each argument to be promoted to a common type. Promote rules have been defined so that promote performs a scalar promotion and a grade promotion. No function currently promotes only the grades of the inputs.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"CliffordNumbers.scalar_promote","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The widen function in Julia Base widens an Number type to a type that can represent the result of addition or subtraction with the the input type without overflowing or losing precision. This functionality is passed through to Clifford numbers, but it only affects the scalar type, not the grades.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"The widen_grade function performs an equivalent operation with the grades of a Clifford number, converting KVector to EvenCliffordNumber or OddCliffordNumber depending on the grade, and converting those to CliffordNumber. New AbstractCliffordNumber subtypes should define this if they intend to promote to types other than CliffordNumber.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"CliffordNumbers.widen_grade","category":"page"},{"location":"types.html#Construction-and-conversion","page":"Types","title":"Construction and conversion","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Clifford numbers can be constructed from other CliffordNumbers. This implicitly performs a grade projection operation, so this construction will always succeed, even if some of the basis blades of the input are lost. By contrast, conversion will throw an InexactError if the result does not contain all of the basis blades of the result.","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"julia> test = CliffordNumber{APS}(1, 2, 3, 4, 5, 6, 7, 8)\n8-element CliffordNumber{VGA(3), Int64}:\n1 + 2σ₁ + 3σ₂ + 5σ₃ + 4σ₁σ₂ + 6σ₁σ₃ + 7σ₂σ₃ + 8σ₁σ₂σ₃\n\njulia> EvenCliffordNumber(test)\n4-element EvenCliffordNumber{VGA(3), Int64}:\n1 + 4σ₁σ₂ + 6σ₁σ₃ + 7σ₂σ₃\n\njulia> convert(EvenCliffordNumber, test)\nERROR: InexactError: ...","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"danger: Danger\nThis is an extremely important point: construction of a Clifford number type with fewer grades than the input performs a grade projection operation. Conversion will throw an error if the result is not exactly representable. This is ***not*** how other subtypes of Number defined by Julia Base behave, as the conversion operation is identical to the constructor.","category":"page"}]
}
